Índice:
	1. Archivos Python
	2. Documentanción

	3. Variables
		.1. Declaración
		.2. Eliminación
		.3. Tipos de variable
			.1. Simples
				.1. Numéricos
				.2. Lógicos
			.2. Compuestos
				.1. Cadenas
				.2. Listas
				.3. Tuplas
				.4. Conjuntos
				.5. Diccionarios
		.4. Cambio de tipo
	4. Operadores
		.1. Asignación
		.2. Aritmeticos
		.3. Asignación aumentada
		.4. Compración
		.5. Lógicos
		.6. Binarios
	5. Entrada y salida de datos
	6. Estructuras de decisión
		.1. Estructura "if"
		.2. Operador ternario
	7. Estructuras de repetición
		.1. Estructura "while"
		.2. Estructura "for"
	8. Comprensión de listas
	9. Generadores
	10. Funciones
		.1. Declaración
		.2. Uso
		.3. Funciones de orden superior
			.1. Funciones anónimas
			.2. Decoradores
		.4. Funciones predefinidas de Python
			.1. del
			.2. filter
			.3. globals
			.4. len
			.5. locals
			.6. map
			.7. max
			.8. min
			.9. next
			.10. range
			.11. zip
	11. Clases
		.1. Declaración
			.1. Herencia
			.2. Polimorfismo
			.3. Métodos especiales
			.4. Encapsulamiento
		.2. Uso
		.3. Métodos predefinidos de Python
			.1. Cadenas
			.2. Diccionarios
			.3. Listas
			.4. Tuplas
			.5. Conjuntos
	12. Manejo de archivos
		.1. Modos
		.2. Métodos y atributos
		.3. Estructura "with"
	13. Programación modular
		.1. Módulos predefinidos
			.1. Expresiones regulares (re)
	14. Excepciones
	15. Almacenamiento
		.1. Archivos
			.1. Binarios
		.2. Bases de datos
	16. Aplicaciones web



Archivos Python:
	<nombre>.py

	Ejecución:
		<ejecutable del intérprete> <archivo Python>

		Ejemplo:
			python3 script.py

		Nota: también pueden crearse como archivos ejecutables de Linux usando el shebang, `#!/usr/bin/env <ejecutable del intérprete>`.

	Nota: para cambiar la codificación del archivo se puede usar el comentario preprocesado `# -*- coding: utf-8 -*-`, a partir de Python 3 ya no es necesario utilizarlo.



Documentación:
	# Comentario, un espacio después del numeral

	<sentencia>  # Comentario, dos espacios antes del numeral

	Nota: se pueden usar las cadenas multilineales como comentarios, aunque técnicamente no lo sean.
		"""
			Comentario
			de varias
			líneas
		"""

	Docstrings:
		Son cadenas que permiten documentar funciones, clases e incluso módulos, para usarlas solo deben escribirse al inicio de cada elemento, por ejemplo:
			· Funciones:
				def prueba(param):
					"""
						Esta es una función de prueba para ver
						el funcionamiento de las Docstrings
					"""

					print(param)

				help(prueba)

				Resultado:
					Help on function prueba in module __main__:

					prueba(param)
					    Esta es una función de prueba para ver
					    el funcionamiento de las Docstrings

			· Clases:
				class prueba():
					"""
						Esta es una clase de prueba para ver
						el funcionamiento de las Docstrings
					"""

					def metodo(self):
						"""
							Este es un método de prueba para ver
							el funcionamiento de las Docstrings
						"""

						print(self)

				help(prueba)

				Resultado:
					Help on class prueba in module __main__:

					class prueba(builtins.object)
					 |  Esta es una clase de prueba para ver
					 |  el funcionamiento de las Docstrings
					 |
					 |  Methods defined here:
					 |
					 |  metodo(self)
					 |      Este es un método de prueba para ver
					 |      el funcionamiento de las Docstrings

			· Módulos:
				prueba.py:
					"""
						Este es un módulo de prueba para ver
						el funcionamiento de las Docstrings
					"""

					class pruebaClase():
						"""
							Esta es una clase de prueba para ver
							el funcionamiento de las Docstrings
						"""

						def metodo(self):
							"""
								Este es un método de prueba para ver
								el funcionamiento de las Docstrings
							"""

							print(self)

					def pruebaFuncion(param):
						"""
							Esta es una función de prueba para ver
							el funcionamiento de las Docstrings
						"""

						print(param)

				script.py:
					import prueba

					help(prueba)

				Resultado:
					Help on module prueba:

					NAME
					    prueba

					DESCRIPTION
					    Este es un módulo de prueba para ver
					    el funcionamiento de las Docstrings

					CLASSES
					    builtins.object
					        pruebaClase

					    class pruebaClase(builtins.object)
					     |  Esta es una clase de prueba para ver
					     |  el funcionamiento de las Docstrings
					     |
					     |  Methods defined here:
					     |
					     |  metodo(self)
					     |      Este es un método de prueba para ver
					     |      el funcionamiento de las Docstrings

					FUNCTIONS
					    pruebaFuncion(param)
					        Esta es una función de prueba para ver
					        el funcionamiento de las Docstrings

					FILE
					    /home/ntrrg/Descargas/prueba.py

		Python permite escribir las Docstrigns de las siguientes maneras:
			· `print(<objeto>.__doc__)`
			· `help(<objeto>)`



Variables:
	Declaración:
		<identificador> = <expresión>
		<identificador>, <otroIdentificador>[, ...] = <expresión>, <otraExpresión>[, ...]  # Asignación múltiple

		Una expresión puede ser un valor directo, una o más varibales acompañadas por operadores e incluso el valor retornado de alguna función o método.

		Formato recomendado para identificadores:
			variable
			variable2
			otra_variable
			otraVariable

	Eliminación:
		del <variable>

		Nota: Si se intenta eliminar una variable indefinida, ocurrirá un error.

	Tipos:
		Simples:
			· Numéricos:
				Inmutable.

				<variable> = <número>

				Ejemplos:
					1  # Entero
					2147483647  # Máximo valor de un entero en 32 bits
					9223372036854775807  # Máximo valor de un entero en 64 bits
					1L  # Numérico largo
					1.0  # Decimal
					1+0j  # Complejo
					0b1  # Binario
					0o1  # Octal
					0x1  # Hexadecimal

				Nota: A partir de Python 3 se eliminaron los enteros largos, por lo que los enteros perdieron su límite máximo.

			· Lógicos:
				Inmutable.

				<variable> = <lógico>

				Ejemplos:
					True  # Verdadero
					False  # Falso
					None  # Vacio

		Compuestos:
			· Cadenas:
				Inmutable, iterable, secuencia.

				<variable> = <cadena>

				Ejemplos:
					'Cadena'
					"Cadena"
					r"Cadena"  # Cadena raw, no escapan caracteres y por esto son útiles para escribir expresiones regulares
					u"Cadena"  # Cadena Unicode
					"""
						Cadena de
						varias líneas
					"""

					Nota: Es posible usar " sin escape dentro de cadenas multilíneales.

			· Tuplas:
				Inmutable, iterable, secuencia.

				<variable> = (<expresión>[, ...])

				Ejemplos:
					(10, "Valor2", 30.0, 4, 5)
					tuple(range(10))
					(1,)  # Tupla de un elemento, es necesario agregar "," al final

				Acceso a sus valores:
					<tupla>[<índice>]

					Ejemplos:
						tupla  # Tupla completa -> (10, 'Valor2', 30.0, 4, 5)
						tupla[0]  # Primer elemento -> 10
						tupla[-1]  # Último elemento -> 5

						Nota: Los índices negativos recorren en sentido opuesto las tuplas, internamente equivalen a restar la cantidad indicada del total de elementos. Ej: tupla[-2] -> tupla[5-2] -> tupla[3] -> 4.

				Porciones (Slicing):
					<tupla>[[<índiceInicial>]:[<índiceFinal+1>]:[<saltos>]]

					Ejemplos:
						tupla[1:3]  # Retorna ('Valor2', 30.0)
						tupla[2:]  # Retorna (30.0, 4, 5)
						tupla[:2]  # Retorna (10, 'Valor2')
						tupla[0:5:2]  # Retorna (10, 30.0, 5)
						tupla[::2]  # También retorna (10, 30.0, 5)
						tupla[:]  # Retorna una copia completa -> (10, 'Valor2', 30.0, 4, 5)

					Notas:
						· Las porciones pueden ser usadas para crear nuevas tuplas con la estructura retornada.
						· Pueden utilizarce índices negativos.
						· Matemáticamente, los índices de las porciones se pueden representar como el intervalo [<índiceInicial>, <índiceFinal>) y por ello es necesario sumar uno al índice final.

			· Listas:
				Mutable, iterable, secuencia.

				<variable> = [<expresión>[, ...]]

				Ejemplos:
					[10, "Valor2", 30.0, 4, 5]
					list(range(10))

				Acceso a sus valores:
					<lista>[<índice>]

					Ejemplos:
						lista  # Lista completa -> [10, 'Valor2', 30.0, 4, 5]
						lista[0]  # Primer elemento -> 10
						lista[-1]  # Último elemento -> 5

						Nota: Los índices negativos recorren en sentido opuesto las listas, internamente equivalen a restar la cantidad indicada del total de elementos. Ej: lista[-2] -> lista[5-2] -> lista[3] -> 4.

				Porciones (Slicing):
					<lista>[[<índiceInicial>]:[<índiceFinal+1>]:[<saltos>]]

					Ejemplos:
						lista[1:3]  # Retorna ['Valor2', 30.0]
						lista[2:]  # Retorna [30.0, 4, 5]
						lista[:2]  # Retorna [10, 'Valor2']
						lista[0:5:2]  # Retorna [10, 30.0, 5]
						lista[::2]  # También retorna [10, 30.0, 5]
						lista[:]  # Retorna una copia completa -> [10, 'Valor2', 30.0, 4, 5]

					Notas:
						· Las porciones pueden ser usadas para crear nuevas listas con la estructura retornada.
						· Pueden utilizarce índices negativos.
						· Matemáticamente, los índices de las porciones se pueden representar como el intervalo [<índiceInicial>, <índiceFinal>) y por ello es necesario sumar uno al índice final.

				Modificación:
					<lista>[<índice>] = <expresión>

					Ejemplos:
						lista[1] = "Valor 2"  # Modificación del 2do elemento de la lista
						lista[1], lista[3] = ("Posición 1", "Posición 3")  # Modificación múltiple por medio de secuencias

						lista[3:5] = (0o12, 50)  # Modificación múltiple por medio de porciones y secuencias
						lista[3:5] = (0o12, 50, "Otro Elemento")  # La porción especificada es sustituida por la secuencia indicada, sin importar su tamaño

						lista[::2] = (1, 3.0, 0x30)  # Modificación múltiple por medio de porciones con saltos, no permite alterar el tamaño de la secuencia original
						lista[1::2] = ("Posiciones Impares",) * 3  # Equivalente a lista[1::2] = ("Posiciones Impares", "Posiciones Impares", "Posiciones Impares")

						lista += (10,)  # Agregar elemento al final
						lista = [20] + lista  # Agregar elemento al início, aunque internamente Python crea un nuevo objeto en base a los objetos "[20]" y "lista"

						del(lista[-1])  # Eliminar un elemento de la lista
						del(lista[0], lista[-1])  # Eliminar varios elementos

						Notas:
							· Aunque no es obligatorio, se usan tuplas para realizar las asignaciones pues internamente son mas ligeras que las listas.
							· Al agregar el elemento al inicio de la lista se uso "[20]" pues durante operaciones, Python no transforma los tipos de variables. En caso de querer usar una tupla se debe usar la función "list()":
								lista = list((20,)) + lista

			· Conjuntos:
				Mutables, iterable, colección.

				<variable> = {<expresión>[, ...]}

				Ejemplo:
					{10, "Valor 2", 30.0, 0b100, 0x5}

				Los conjuntos eliminan automáticamente elementos repetidos y permiten realizar operaciones algebraicas de conjuntos como unión, itersección, diferencia y diferencia simétrica.

				Notas:
					· Es posible crear un conjunto inmutable con la clase "frozenset()".
					· Los conjuntos mutables no pueden usarse como parte de otros conjuntos.
					· Los conjuntos no pueden usarse para crear diccionarios.
					· No es posible acceder a sus valores, pero si pueden ser modificados por medio de sus métodos.

			· Diccionarios:
				Mutable, iterable, mapa.

				<variable> = {<clave> : <expresión>[, ...]}

				Ejemplo:
					{"Clave 1": "Valor 1", "Clave 2": 2, "Clave 3": 3.0}

				Acceso a sus valores:
					<diccionario>[<clave>]

					Ejemplos:
						diccionario  # Diccionario completo -> {'Clave 1': 'Valor 1', 'Clave 2': 2, 'Clave 3': 3.0}
						diccionario["Clave 1"]  # Elemento específico -> "Valor 1"

				Modificación:
					<diccionario>[<clave>] = <valor>

					Ejemplos:
						diccionario["Clave 2"] = "Segundo valor"
						diccionario["Clave 4"] = 4  # Si no existe la clave indicada, se creará un nuevo elemento
						diccionario["Clave 1"], diccionario["Clave 5"] = (1, "Valor 5")  # Asignación múltiple

						del(diccionario["Clave 4"])  # Eliminar un elemento del diccionario
						del(diccionario["Clave 2"], diccionario["Clave 3"])  # Eliminar varios elementos

				Notas:
					· Las colecciones no son almacenadas en un orden específico, por lo que si se ejecuta varias veces un script donde se muestre un diccionario, su salida puede variar.
					· Si se usa un diccionario donde se espera un iterable o una secuencia, se obtendrán sus claves y no sus valores.

	Cambio de tipo:
		Es posible cambiar (cast) el tipo de dato de una variable llamando clases predefinidas de Python:
			Simples:
				· Numéricos:
					int()
						int(10.6)  # Retorna 10, pues no realiza operación de redondeo
						int(0b110)  # Retorna 6
						int(0o14)  # Retorna 12
						int(0x1e)  # Retorna 30

					float()
						float(5)  # Retorna 5.0
						float(0b110)  # Retorna 6.0
						float(0o14)  # Retorna 12.0
						float(0x1e)  # Retorna 30.0

					complex()
						complex(5)  # Retorna (5+0j)
						complex(0b110)  # Retorna (6+0j)
						complex(0o14)  # Retorna (12+0j)
						complex(0x1e)  # Retorna (30+0j)


					bin()  # Retorna una cadena con el número binario pues Python lo interpretaría
						bin(5)  # Retorna '0b101'
						bin(0o14)  # Retorna '0b1100'
						bin(0x1e)  # Retorna '0b11110'

					oct()  # Retorna una cadena con el número octal pues Python lo interpretaría
						oct(5)  # Retorna '0o5'
						oct(0b110)  # Retorna '0o6'
						oct(0x1e)  # Retorna '0o36'

					hex()  # Retorna una cadena con el número hexadecimal pues Python lo interpretaría
						hex(5)  # Retorna '0x5'
						hex(0b110)  # Retorna '0x6'
						hex(0o14)  # Retorna '0xc'

				· Lógicos:
					bool()
						bool(0)  # Retorna False
						bool(1)  # Retorna True
						bool("")  # Retorna False
						bool("M")  # Retorna True
						bool([])  # Retorna False
						bool([1, 2])  # Retorna True

			Compuestos:
				· Cadenas:
					str()
						str(10)  # Retorna '10'
						str(0b110)  # Retorna '6', Python interpreta automaticamente los numeros binarios, octales y hexadecimales
						str(True)  # Retorna 'True'
						str(lista)  # Retorna '[1, 'Posiciones Impares', 3.0, 'Posiciones Impares', 48]'
						str({3, 5, 2, 4, 1})  # Retorna '{1, 2, 3, 4, 5}'

				· Tuplas:
					tuple()
						tuple("Ntrrg")  # Retorna ('N', 't', 'r', 'r', 'g')
						tuple(range(5))  # Retorna (0, 1, 2, 3, 4)
						tuple([1, 3, 5, 7])  # Retorna (1, 3, 5, 7)
						tuple({3, 5, 2, 4, 1})  # Retorna (1, 2, 3, 4, 5)
						tuple({"Clave 1" : 1, "Clave 2" : 2})  # Retorna ('Clave 2', 'Clave 1'), el orden es irrelevante para los diccionarios

				· Listas:
					list()
						list("Ntrrg")  # Retorna ['N', 't', 'r', 'r', 'g']
						list(range(5))  # Retorna [0, 1, 2, 3, 4]
						list((1, 3, 5, 7))  # Retorna [1, 3, 5, 7]
						list({3, 5, 2, 4, 1})  # Retorna [1, 2, 3, 4, 5]
						list({"Clave 1" : 1, "Clave 2" : 2})  # Retorna ['Clave 2', 'Clave 1'], el orden es irrelevante para los diccionarios

				· Conjuntos**:
					set()
						set("Ntrrg")  # Retorna {'r', 'g', 'N', 't'}
						set((1, 2, 3, 4, 5))  # Retorna {1, 2, 3, 4, 5}

					frozenset()  # Versión inmutable
						frozenset("Ntrrg")  # Retorna frozenset({'r', 'g', 'N', 't'})
						frozenset((1, 2, 3, 4, 5))  # Retorna frozenset({1, 2, 3, 4, 5})

				· Diccionarios:
					dict()
						dict([("Nombre", "Miguel Angel"), ("Apellido", "Rivera Notararigo")])  # Retorna {'Nombre': 'Miguel Angel', 'Apellido': 'Rivera Notararigo'}
						dict(zip(("Clave 1", "Clave 2"), ("Valor 1", "Valor 2")))  # Retorna {'Clave 2': 'Valor 2', 'Clave 1': 'Valor 1'}

			Nota: Para conocer el tipo de una variable se usa la función "type(<variable>)".

Operadores:
	Asignación:
		=: <variable> = <expresión>
		= or: <variable> = <expresión> or <otraExpresión>  # Si <expresión> no es falsa asigna su valor a <variable>, de lo contrario <variable> toma el valor de <otraExpresión>
		= and: <variable> = <expresión> and <otraExpresión>  # Si <expresión> y <otraExpresión> son verdaderas, <variable> toma el valor de <otraExpresión>

	Aritmeticos:
		+: Suma, concatenación.
		-: Resta.
		*: Multiplicación.
		/: División.
		%: Módulo, formateo de cadenas.
		//: División entera.
		**: Exponente, radical.

	Comparación:
		==: <expresión> == <expresión>  # Retorna verdadero si ambas expresiones son iguales
		!=: <expresión> != <expresión>  # Retorna verdadero si ambas expresiones son diferentes
		<: <expresión> < <expresión>  # Retorna verdadero si la primera expresión es menor que la segunda
		<=: <expresión> <= <expresión>  # Retorna verdadero si la primera expresión es menor o igual que la segunda
		>: <expresión> > <expresión>  # Retorna verdadero si la primera expresión es mayor que la segunda
		>=: <expresión> >= <expresión>  # Retorna verdadero si la primera expresión es mayor o igual que la segunda
		is: <expresión> is <expresión>  # Retorna verdadero si ambas expresiones tienen el mismo identificador.
		is not: <expresión> is not <expresión>  # Retorna verdadero si ambas expresiones tienen diferentes identificadores.

		Nota: Para obtener el identificador (apuntador a un espacio de memoria) de una variable se usa la función "id(<variable>)".

	Lógicos:
		not: not <expresión>  # Retorna verdadero si la expresión es falsa
		and: <expresión> and <expresión>  # Retorna verdadero si ambas expresiones son verdaderas
		or: <expresión> or <expresión>  # Retorna verdadero si al menos una expresión es verdadera
		xor: <expresión> xor <expresión>  # Retorna verdadero solo si una expresión es verdadera

	Binarios:
		~ (not): Invertir bit a bit.
		& (and): Obtiene 1 si ambos bit son 1.
		| (or): Obtiene 1 si al menos un bit es 1.
		^ (xor): Obtiene 1 si solo un bit es 1.
		>> <número>: Desplaza <número> bits a la derecha.
		<< <número>: Desplaza <número> bits a la izquierda.

	Asignación aumentada:
		+=: <variable> += <expresión>  # Equivalente a <variable> = <variable> + <expresión>
		-=: <variable> -= <expresión>  # Equivalente a <variable> = <variable> - <expresión>
		*=: <variable> *= <expresión>  # Equivalente a <variable> = <variable> * <expresión>
		/=: <variable> /= <expresión>  # Equivalente a <variable> = <variable> / <expresión>
		%=: <variable> %= <expresión>  # Equivalente a <variable> = <variable> % <expresión>
		//=: <variable> //= <expresión>  # Equivalente a <variable> = <variable> // <expresión>
		**=: <variable> **= <expresión>  # Equivalente a <variable> = <variable> ** <expresión>
		&=: <variable> &= <expresión>  # Equivalente a <variable> = <variable> & <expresión>
		|=: <variable> |= <expresión>  # Equivalente a <variable> = <variable> | <expresión>
		^=: <variable> ^= <expresión>  # Equivalente a <variable> = <variable> ^ <expresión>
		>>: <variable> >>= <número>  # Equivalente a <variable> = <variable> >> <número>
		<<: <variable> <<= <número>  # Equivalente a <variable> = <variable> << <número>

		Nota: Python no permite los operadores ++ y -- usados en otros lenguajes de programación.

	Nota: Antes y después de cada operador se debe escribir un espacio.

Salida:
	· Estandar:
		print [<expresión>[, ...][,]]  # Python 2
		print([<expresión>[, ...]])  # Python 3

		Ejemplos:
			print("Hola, bienvenido a Pytrrg :B")  # Añade automaticamente un salto de línea.
			print("Lista de practicas: " + str([1, 5, 10]))  # Es posible concatenar datos pero deben ser del mismo tipo

		Nota:
			· En Python 2, el uso de una coma al final de la línea, cambiará el salto de línea automático por un espacio.
			· A partir de Python 3, "print" se convirtió en una función.
				print([<expresión>[, ...][, sep = <separador>][, end = <finDeSalida>][, flush = True | false]])

				Parámetros:
					· sep: Determina con que se separan las expresiones, " " es el valor predeterminado.
					· end: Determina con que termina la salida, "\n" es el valor predeterminado.
					· flush: Forza la limpeza del buffer, False es el valor predeterminado.

		Escape de caracteres:
			\<caracter>: Evita que <caracter> tenga un comportamiento especial.
			\b: Borrar un caracter.
			\n: Salto de línea.
			\r: Retorno de carro.
			\t: Tabulador.
			\v: Tabulador vertical.

Entrada:
	· Estandar:
		<variable> = input([<expresión>])

		Notas:
			· Solo admite un parámetro, por lo que debe usarse el operador "+" para escribir cadenas compuestas.
			· Permite escribir cadenas como "print()" por lo que posee sus utilidades, aunque no aplica el salto de línea automático.
			· En Python 2, para leer cadenas con esta función es necesario escribirlas con comillas, pues lee como si se estuviese escribiendo directamente en el intérprete. Para evitar este comportamiento se usa "raw_input()" pero cualquier dato que se lea será convertido en una cadena.

Estructuras de decisión:
	Condición:
		[not] <expresión> [<operadorDeComparación> <otraExpresión>]

	· If:
		if <condición> [<operadorLógico> <otraCondición> [...]]:
			<sentencias>

		[elif <condición> [<operadorLógico> <otraCondición> [...]]:
			<sentencias>]

		[else:
			<sentencias>]

	· Operador ternario:
		<sentencia> if <condición> [<operadorLógico> <otraCondición> [...]] else <otraSentencia>  # Ejecuta <sentencia> si se cumple <condición>, de lo contrario ejecuta <otraSentencia>

Estructuras de repetición:
	· While:
		while <condición> [<operadorLógico> <otraCondición> [...]]:
			<sentencias>

		[else:
			# Se ejecuta solo si la condición es o se convierte en falsa
			<sentencias>]

	· For:
		for <variable> in <iterable>:
			<sentencias>

		[else:
			# Se ejecuta solo si se recorre completamente <iterable>
			<sentencias>]

		Notas:
			· <variable> tomará el valor de cada uno de los elementos de <iterable> por repetición.
			· Al recorrer diccionarios, <variable> toma el valor de las claves y para acceder a sus valores debería usarse el operador "[]", ej: <diccionario>[<variable>].

		Tecnicas de bucle:
			· Manejo de diccionarios:
				for <clave>, <valor> in <diccionario>.items():
					<sentencias>

			· Índices en secuencias:
				for <índice>, <valor> in enumerate(<secuencia>[, <índiceInicial>]):
					<sentencias>

			· Asignación múltiple:
				for <variable>, <otraVariable> in (<secuencia>, <otraSecuencia>):
					<sentencias>

				Ejemplo:
					for a, b, c in ("ABC", [1, "Valor 1", "Otro mas 1"]):
						print(a, b, c)

			· Asignación múltiple a partir de múltiples secuencias:
				for <variable>, <otraVariable> in zip(<secuencia>, <otraSecuencia>):
					<sentencias>

				Ejemplo:
					for a, b, c in zip("AB", [1, "Valor 1"], (2, "Valor 2")):
						print(a, b, c)

				Nota: La diferencia entre esta técnica y la anterior, es que con "zip()" se fusionan las secuencias. Ejemplo:
					for a, b in ("AB", (1, 2)):
						# 1 -> a = "A", b = "B"
						# 2 -> a = 1, b = 2
					for a, b in zip("AB", (1, 2)):
						# 1 -> a = "A", b = 1
						# 2 -> a = "B", b = 2

			· Porciones de <secuencia>:
				Al realizar cambios en los índices de <secuencia>, es probable que la estructura entre en un ciclo infinito, pero puede evitarse de la siguiente manera:
					for <variable> in <secuencia>[:]:
						<secuencia>.append(<valor>)
						<sentencias>

	Notas:
		· Es posible evitar una repetición con la palabra reservada "continue" y si la condición se cumple se ejecutará la proxima repetición.
		· Es posible finalizar una estructura de repetición con la palabra reservada "break".

Comprensión de listas:
	Permite crear listas en base a algún iterable.
		[<expresión> for <variable> in <iterable> [if <condiciones>]]

	Ejemplos:
		Obtener la mitad de cada elemento de un iterable:
			l = range(1, 10)

			[n / 2.0 for n in l]  # Para Python 2
			[n / 2 for n in l]  # Para Python 3

		Obtener las vocales de una cadena:
			vocales = ("a", "e", "i", "o", "u", "A", "E", "I", "O", "U")
			c = "Miguel Angel Rivera Notararigo"

			[v for v in c if v in vocales]

		Resultados de la tabla de multiplicar:
			[x * y for x in range(1, 10) for y in range(1, 11)]

		Resultados de la tabla de multiplicar de los números pares:
			[x * y for x in range(1, 10) if x % 2 == 0 for y in range(1, 11)]

		Resultados de la tabla de multiplicar de los números pares solo con los números impares:
			[x * y for x in range(1, 10) if x % 2 == 0 for y in range(1, 11) if y % 2 == 1]

Generadores:
	Permiten crear iteradores temporales. En lugar de almacenar una lista de elementos, guarda las instrucciones para calcularlos en cada invocación. Pueden definirse por medio de dos sintaxis:

		Como comprensión de listas:
			(<expresión> for <variable> in <iterable> [if <condiciones>])

			Ejemplo:
				numeros = (n for n in range(5))  # Generador de números del 0 al 4

				next(numeros)  # Retorna 0
				next(numeros)  # Retorna 1

		Como función:
			def <nombre>():
				<sentencias>
				yield <expresión>

			Ejemplo:
				def generador():
					for n in range(5):
						yield n

				numeros = generador()  # Generador de números del 0 al 4

				next(numeros)  # Retorna 0
				next(numeros)  # Retorna 1

			Nota: "yield" retorna el valor que corresponde a la iteración y guarda el estado de la función para poder generar el siguiente valor.

Funciones:
	Declaración:
		def <nombre>(<parámetro> [= <valorPredefinido>][, ...][, *<parámetrosExtras>][, **<parámetrosExtras>]):
			"""<título>.

				<documentación>
			"""

			# Esta documentación es llamada Docstring, no es obligatoria pero es recomendable siempre explicar para que sirve la función definida. Python permite escribir esta documentanción de las siguientes maneras:
			#	· print(<nombre>.__doc__)
			#	· help(<nombre>)

			<sentencias>
			[return <expresión>[, ...]]  # Si no se especifica, retornará "None"

		Notas:
			· <nombre> actuará como una variable común si no se usa el operador "()", por lo que puede asignarse el contenido de una función a otra variable.
			· <parámetro> es una variable que guardará un valor externo para usarlo dentro de la función.
			· *<parámetrosExtras> es una tupla donde se empaquetan todos los parámetros extras especificados en la invocación de la función.
			· **<parámetrosExtras> es un diccionario donde se empaquetan todos los parámetros extras especificados con <clave> = <valor> en la invocación de la función.
			· Es posible predefinir los valores de los parámetros con "= <valor>" en caso de que al invorcarse no se especifique alguno o no sean suficientes.
			· Todas la variables definidas en el cuerpo del script son globales, por lo que se puede acceder a su valor dentro de cualquier función, solo las variables definidas dentro de la función tienen ambito local. Ejemplo:
				def mostrar():
					print(cadena)
					cadena2 = "Segunda cadena"

				cadena = "Primera cadena"

				print(cadena2)  # Generará un error porque no encuentra la variable "cadena2"

			· Si se retorna más de un valor, todos son retornados como una tupla.

	Uso:
		<función>(<expresión>[, ...][, *<secuencia>][, **<diccionario>])

		Notas:
			· Las variables usadas para asignar valores a parámetros, se modificarán después de la ejecución de la función solo si son mutables (listas y diccionarios).
			· Los valores serán asignados según el orden de los parámetros en la declaración de la función.
			· Para evitar que la asignación de los parámetros sea en el orden de la declaración se puede invocar una función de la siguiente manera:
				<función>(<otroParámetro> = <otroExpresión>, <parámetro> = <expresión>)
			· También pueden usarse los operadores "*" y "**" en la invocación, solo que tendrán un resultado invertido (desempaquetar):
				<función>(*(<expresión>, <otraExpresión>))  # <parámetro> = <expresión>, <otroParámetro> = <otraExpresión>
				<función>(*[<otraExpresión>, <expresión>])  # <parámetro> = <otraExpresión>, <otroParámetro> = <expresión>
				<función>(**{<otroParámetro> : <otraExpresión>, <parámetro> : <expresión>})  # <parámetro> = <expresión>, <otroParámetro> = <otraExpresión>
			· Es posible guardar el valor retornado por las funciones en cualquier variable.

	Funciones de orden superior:
		def <nombre>():
			def <otroNombre>():
				<sentencias>
				[return <expresión>]

			<sentencias>
			[return <expresión>]

		Ejemplo:
			def calculadora(expresion):
				def suma(numero, otroNumero):
					return numero + otroNumero

				def resta(numero, otroNumero):
					return numero - otroNumero

				expresion = expresion.split()

				if expresion[1] == "+":
					return suma(float(expresion[0]), float(expresion[2]))

				elif expresion[1] == "-":
					return resta(float(expresion[0]), float(expresion[2]))

				else:
					return "Operacion no soportada"

			print(calculadora("2 + 2"))
			print(calculadora("5 - 3"))

			También las funciones que reciban como parámetro o retornen otras funciones son llamadas funciones de orden superior. Ejemplo:
				def calculadora(operacion):
					def suma(numero, otroNumero):
						return numero + otroNumero

					def resta(numero, otroNumero):
						return numero - otroNumero

					if operacion == "1":
						return suma

					elif operacion == "2":
						return resta

					else:
						print("Operacion no soportada")
						return False

				operacion = input("""Que operacion desea realizar?
				1. Suma
				2. Resta
				""")

				print(calculadora(operacion)(2, 3))

		Nota: Ver las funciones predefinidas "filter()" y "map()".

		Funciones anónimas:
			lambda <parámetro>[, ...] : <expresión>

			Ejemplo:
				l = range(1900, 2000)

				filter(lambda n : n % 4 == 0 and (n % 100 != 0 or n % 400 == 0), l)  # Retorna los años bisiestos del siglo XX

			Nota: Solo puede ejecutar una expresión y el valor obtenido de ella será el de retorno.

		Decoradores:
			def <nombre>(<funcion>):
				def <lanzador>(<parámetro>[, ...]):
					<sentencias>
					[return ]<funcion>(<parámetro>[, ...])

				return <lanzador>

			@<nombre>
			def <funcionADecorar>(<parámetro>[, ...]):
				sentencias
				[return <expresión>]

			Ejemplo:
				def registroDeActividades(funcion):
					def decorador(*parámetros, **otrosParámetros):
						registro.append("Se ejecuto la funcion \"" + funcion.__name__ + "()\" con " + str(len(parámetros)) + " parámetros " + str(parámetros))
						return funcion(*parámetros, **otrosParámetros)

					return decorador

				@registroDeActividades
				def funcion1(p1):
					return p1

				@registroDeActividades
				def funcion2(p1, p2):
					return p1 + p2

				registro = []

				print(funcion1("Hola"))
				print(funcion2(2, 3))

				print(registro)

	Predefinidas:
		· filter():
			filter(<función>, <secuencia>)

			Permite validar lo elementos de una secuencia, <función> debe retornar verdadero o falso dependiendo de si el elemento pasa la validación. Al final, retorna una lista con los elementos validos. Ejemplo:
				def prueba(n):
					if n > 2:
						return True

				l = range(5)

				filter(prueba, l)  # Retorna los valores mayores a 2 -> [3, 4]

			Nota: A partir de Python 3 "filter()" es una clase y retorna un dato de tipo filter.

		· globals():
			globals()

			Retorna un diccionario con el namespace global.

		· len():
			len(<iterable>)

			Retorna la cantidad de elementos en un iterable. Ejemplo:
				len([1, 2])  # Restorna 2

		· locals():
			locals()

			Retorna un diccionario con el namespace local.

		· map():
			map(<función>, <iterable>[, ...])

			Permite aplicar "<función>" a cada elemento del iterable especificado y al final retorna una lista con los valores retornados de cada invocación. Ejemplo:
				def prueba(v):
					print v
					return v

				l = range(5)

				map(prueba, l)  # Mostrará todos los número del rango y al final retornará [0, 1, 2, 3, 4]

			Si la función no retorna algún valor, la lista almacenará "None". Ejemplo:
				def prueba(v):
					if v % 2 == 0:
						return v

				l = range(5)

				map(prueba, l)  # Retornará solo los valores pares y el 0, [0, None, 2, None, 4]

			El número de parámetros que reciba <función> dependerá de la cantidad de iterables especificados. Ejemplo:
				def prueba(v, v2):
					return v, v2

				l = range(3)
				l2 = "abc"

				map(prueba, l, l2)  # Retornará [(0, 'a'), (1, 'b'), (2, 'c')]

			En caso de que los iterables sean asimétricos, se retornará "None" en donde corresponda el valor del iterables más corto. Ejemplo:
				def prueba(v, v2):
					return v, v2

				l = range(2)
				l2 = "abc"

				map(prueba, l, l2)  # Retornará [(0, 'a'), (1, 'b'), (None, 'c')]

			Si se usan diccionarios, como en los demás casos, se obtendrán sus claves. Ejemplo:
				def prueba(v, v2):
					return v, l2[v2]

				l = range(3)
				l2 = {"a" : 2, "b" : 1, "c" : 0}

				map(prueba, l, l2)  # Retornará [(0, 2), (1, 0), (2, 1)]

			Nota: A partir de Python 3 "map()" es una clase y retorna un dato de tipo map.

		· max():
			max(<iterable>)

			Retorna es valor máximo de un iterable.

			Nota: En Python 3 los valores del iterable deben ser del mismo tipo.

		· min():
			min(<iterable>)

			Retorna es valor mínimo de un iterable.

			Nota: En Python 3 los valores del iterable deben ser del mismo tipo.

		· next():
			next(<generador>[, <valorPredefinido>])

			Obtiene el siguiente valor de un generador. Ejemplo:
				generador = (n for n in range(2))

				next(numeros)  # Retorna 0
				next(numeros)  # Retorna 1
				next(numeros)  # Generará un error porque no existen más valores calculables

			Nota: Si se especifica "<valorPredefinido>", cuando se acaben los valores calculables no generará un error sino usará "<valorPredefinido>".

		· range():
			range([<valorInicial>, ]<valorFinal+1>[, <aumento>])

			Permite generar rangos numéricos. Ejemplos:
				range(5)  # Números del 0 al 4
				range(1, 10)  # Números del 1 al 9
				range(-5, 6)  # Números del -5 al 5
				range(2, 21, 2)  # Números pares del 1 al 20
				range(-1, -20, -2)  # Números impares del -1 al -20
				range(-19, 0, 2)  # Números impares del -1 al -20 en orden ascendente

			Notas:
				· Para definir <aumento>, es necesario especificar <valorInicial>.
				· A partir de Python 3, range() es una clase y retorna un dato de tipo range.

		· round():
			round(<expresiónNumérica>[, <precisión>])

			Redondea <expresiónNumérica> hasta <precisión> decimales, si no se especifica <precisión> se eliminarán los decimales (después de redondearlos) y se retonará un entero.

		· zip():
			zip(<iterable>[, ...])

			Crear una lista compuesta por tuplas a partir de dos o más iterables: Ejemplos:
				zip((1, 2), [2, 1])  # Retorna [(1, 2), (2, 1)]

			Notas:
				· La cantidad de tuplas en la lista dependerá de la cantidad de elementos que tengan los parámetros.
					zip((1, 2), [2, 1, 3])  # Retorna [(1, 2), (2, 1)]
					zip((1, 2), [2, 1, 3], (1,))  # Retorna [(1, 2, 1)]
				· Si se empaqueta un diccionario, solo se tomarán sus claves.
					zip((1, 2), {"Clave" : 1, "Clave2" : 2})  # Retorna [(1, 'Clave'), (2, 'Clave2')]
				· A partir de Python 3, zip() es una clase y retorna un dato de tipo zip.

Clases:
	Declaración:
		class <nombre>:
			"""<título>.

				<documentación>
			"""

			# Las clases también tienen Docstrings.

			[<atributo> = <expresión>]

			def __init__(self[, <parámetro>[, ...]]):
				self.<atributo> = <expresión> | <parámetro>
				<sentencias>

			[def <nombreMétodo>(self[, <parámetro>[, ...]]):
				<sentencias>
				[return <expresión>]]

		Notas:
			· <nombre> debe ser singular y las primeras letras deben ser mayúsculas. Ejemplo:
				class Nombre:
				class OtraClase:

			· El uso de "__init__" es casi obligatorio porque es el método que se encarga de construir los objetos. Se dice que es casi obligatorio porque pueden asignarse atributos sin él pero solo contendrán valores estáticos y en caso de ser mutables, compartirán su valor en todas las instancias.
			· Todos los métodos deben tener al menos un parámetro porque Python envía automáticamente la referencia al objeto, por convenio se usa la palabra "self".
			· Los atributos se comportan como variables y los métodos como funciones.

		Herencia:
			class <nombre>(<superClase>[, ...]):
				[<atributo> = <expresión>]

				# Es posible rescribir el método "__init__" si la nueva clase necesita asignar algunos parámetros durante su instanciación
				[def __init__(self[, <parámetro>[, ...]]):
					<superClase>.__init__(self[, <parámetro>[, ...]])  # Es necesario pasar "self" como parámetro

					self.<atributo> = <expresión> | <parámetro>
					<sentencias>]

				[def <nombreMétodo>(self[, <parámetro>[, ...]]):
					<sentencias>
					[return <expresión>]]

			Nota: Los atributos y métodos de las superclases más a la izquierda no serán sobrescritos, a menos que se definan dentro de la clase que se está creando.

		Polimorfismo:
			En Python 2 no es muy relevante por su tipado debil, pero en Python 3 puede aplicarse por medio de los métodos especiales.

		Atributos especiales:
			· __dict__: Retorna un diccionario con los elementos del objeto, es posible modificarlo.
				print(obj.nombre)  # Nombre

				obj.__dict__["nombre"] = "Nuevo Nombre"

				print(obj.nombre)  # Nuevo Nombre

				Nota: Posee todos los métodos de un diccionario.

			· __name__: Contiene el nombre de la clase.

		Métodos especiales:
			· __del__: Se ejecuta cuando se elimina el objeto (usando "del(<objeto>)" o cuando finaliza la ejecución del script).
				def __del__(self):
					<sentencias>

			· __str__: Permite configurar la salida al momento de mostrar el objeto como una cadena (usando "str(<objeto>)" o "print(<objeto>)").
				def __str__(self):
					<sentencias>
					return <cadena>

			· __lt__ (<)
			  __le__ (<=)
			  __eq__ (==)
			  __ne__ (!=)
			  __gt__ (>)
			  __ge__ (>=): Se invocan al momento utilizar operadores de comparación con el objeto.
				def <métodoEspecial>(self, <valorDeComparación>):
					<sentencias>
					return True | False

				Nota: Es posible retornar cualquier tipo de valor, pero en la mayoría de los casos serán True o False.

			· __bool__: Permite configurar la salida al momento de mostrar el objeto como un valor lógico (usando "bool(<objeto>)").
				def __bool__(self):
					<sentencias>
					return True | False

			· Más métodos especiales: https://docs.python.org/3.5/reference/datamodel.html#special-method-names

		Encapsulamiento:
			class <nombre>:
				__<atributoPrivado> = <valor>

				def __<métodoPrivado>(self):
					<sentencias>
					[return <expresión>]

			Nota: A pesar que se definan atributos y métodos privados es posible acceder a ellos con la sintaxis "<objeto>._<nombreClase>__<atributoPrivado>" o "<objeto>._<nombreClase>__<métodoPrivado>()".

		Función "property()":
			Permite crear atributos del tipo "property", son de gran utilidad pues dependiendo de como se usen, ejecutarán una función diferente, por ejemplo:
				<objeto>.<propiedad>  # Lectura
				<objeto>.<propiedad> = <valor>  # Escritura
				del <objeto>.<propiedad>  # Eliminación

			Su uso más frecuente es controlar la lectura, escritura y eliminación de un atributo, trabajando en conjunto con el encapsulamiento.

			Sintaxis:
				class <nombre>:
					def __init__(self[, <parámetro>[, ...]]):
						self.__<atributo>

					def <función de lectura>(self):
						<sentencias>

						return <valor>

					def <función de escritura>(self, <parametro>):
						# <parametro> recibe el valor a asignar

						<sentencias>

					def <función de eliminación>(self):
						<sentencias>

					<atributo> = property([fget = <función de lectura>][, fset = <función de escritura>][, fdel = <función de eliminación>][, doc = <documentación>])

				Nota: En caso de no definirse "doc", "property" intentará usar la Docstring de <función de lectura>.

				Además de esta, existe una sintaxis que usa decoradores:
					class <nombre>:
						def __init__(self[, <parámetro>[, ...]]):
							self.__<atributo>

						# Lectura
						@property
						def <atributo>(self):
							<sentencias>

							return <valor>

						# Escritura
						@<atributo>.setter
						def <atributo>(self, <parametro>):
							# <parametro> recibe el valor a asignar

							<sentencias>

						# Eliminación
						@<atributo>.deleter
						def <atributo>(self):
							<sentencias>

					Notas:
						· Todas las funciones deben tener el nombre del parámetro.
						· Al igual que en la sintaxis anterior, "property" intentará usar la Docstring de la función de lectura.

	Uso:
		<objeto> = <clase>([<parámetro>[, ...]])  # Instanciación. Esto invocará el método "__init__" si esta definido y pasará los parámetros si se especifican

		<objeto>.<atributo>  # Accede al valor del atributo especificado, su comportamiento es como el de una variable común

		<objeto>.<método>([<parámetro>[, ...]])  # Invoca el método especificado, su comportamiento es como el de las funciones por lo que comparte todas sus utilidades

	Métodos predefinidos:
		Cadenas:
			· Agregar ceros a la izquierda:
				<cadena>.zfill(<espacios>)

			· Alinear a la derecha:
				<cadena>.rjust(<espacios>[, <caracter>])

				Ejemplo:
					"Citado de un artíco de internet".rjust(40)  # Si no se define "<caracter>" se usan espacios en blanco

			· Alinear a la izquierda:
				<cadena>.ljust(<espacios>[, <caracter>])

				Nota: Es es comportamiento usual de una cadena, pero puede ser util para llenar los espacios en blanco a la derecha.

			· Alinear al centro:
				<cadena>.center(<espacios>[, <caracter>])

				Ejemplo:
					"Bienvenidos a Pytrrg".center(40)  # Si no se define "<caracter>" se usan espacios en blanco

			· Buscar subcadena:
				<cadena>.find(<subcadena>[, <índiceInicial>[, <índiceFinal+1>]])  # Retorna el índice de la primera coincidencia o -1 si no se encuentra
				<subcadena> in <cadena>  # Retorna verdadero o falso dependiendo de si encuentra la subcadena en la cadena

				Nota: "<subcadena>" puede ser una expresión.

			· Cantidad de apariciones de una subcadena:
				<cadena>.count(<subcadena>[, <índiceInicial>[, <índiceFinal+1>]])

				Nota: "<subcadena>" puede ser una expresión.

			· Codificar/Decodificar:
				<cadena>.encode([<codificación>])  # Retorna un objeto bytes

				<bytes>.decode([<codificación>])  # Retorna una cadena

			. Concatenar por medio de una cadena:
				<cadena>.join(<secuencia>)

				Ejemplo:
					" ".join("Ntrrg")  # Retorna 'N t r r g'
					" ".join(("Hola", ":B"))  # Retorna 'Hola :B'

				Nota: "<secuencia>" solo debe contener datos de tipo cadena.

			· Convertir a mayúsculas:
				<cadena>.upper()

			· Convertir a minúsculas:
				<cadena>.lower()

			· Convertir la primera letra de cada palabra en una cadena a mayúscula:
				<cadena>.title()

			· Convertir la primera letra de una cadena en mayúscula y las demás en minúsculas:
				<cadena>.capitalize()

			· Convertir mayúsculas en minúsculas y minúsculas en mayúsculas:
				<cadena>.swapcase()

			· Desconcatenar:
				<cadena>.split([<subcadena>[, <veces>]])

				Ejemplos:
					"www.pagina.com".split(".")  # Retorna ['www', 'pagina', 'com']
					"www.pagina.com".split(".", 1)  # Retorna ['www', 'pagina.com']
					"www.pagina.com".split(",")  # Retorna ['www.pagina.com']

				Notas:
					· "<subcadena>" puede ser una expresión.
					· Si no se especifica "<subcadena>" se usará " ".
					· Si no se encuentra "<subcadena>" se retornará una lista de un elemento.

			· Desconcatenar con saltos de línea:
				<cadena>.splitlines()

				Nota: Acepta los saltos de línea escapados "\n".

			· Determinar si una cadena empieza con una subcadena específica:
				<cadena>.startswith(<subcadena>[, <índiceInicial>[, <índiceFinal+1>]])

			· Determinar si una cadena termina con una subcadena específica:
				<cadena>.endswith(<subcadena>[, <índiceInicial>[, <índiceFinal+1>]])

			· Determinar si una cadena es alfabetica:
				<cadena>.isalpha()

				Nota: No acepta los espacios en blanco.

			· Determinar si una cadena es alfanumérica:
				<cadena>.isalnum()

			· Determinar si una cadena es numérica:
				<cadena>.isdigit()

			· Determinar si una cadena esta en mayúsculas:
				<cadena>.isupper()

				Nota: Acepta espacios y números.

			· Determinar si una cadena esta en minúculas:
				<cadena>.islower()

				Nota: Acepta espacios y números.

			· Determinar si una cadena tiene solo espacios en blanco:
				<cadena>.isspace()

				Nota: Si esta vacía retorna "False".

			· Determinar si una cadena tiene formato de título:
				<cadena>.istitle()

				Nota: Acepta espacios y números.

			· Dividir cadena:
				<cadena>.partition(<subcadena>)  # Solo divide hasta la primera coincidencia de "<subcadena>"

				Ejemplos:
					"Prueba de partition".partition(" ")  # Retorna ('Prueba', ' ', 'de partition')

				Notas:
					· "<subcadena>" puede ser una expresión.
					· Si no se encuentra "<subcadena>" retorna la cadena completa en la primera posición y dos cadenas vacias en las demás.
						"Prueba de partition".partition("&")  # Retorna ('Prueba de partition', '', '')

			· Eliminar caracteres a la derecha:
				<cadena>.rstrip([<caracter>])

				Nota: Si no se especifica "<caracter>" borrará espacios en blanco.

			· Eliminar caracteres a la izquierda:
				<cadena>.lstrip([<caracter>])

				Nota: Si no se especifica "<caracter>" borrará espacios en blanco.

			· Eliminar caracteres a la izquierda y derecha:
				<cadena>.strip([<caracter>])

				Nota: Si no se especifica "<caracter>" borrará espacios en blanco.

			· Remplazar subcadenas:
				<cadena>.replace(<subcadena>, <nuevaSubcadena>[, <veces>])

				Ejemplos:
					"Cadena".replace("a", "A")  # Retorna 'CAdenA'
					"Cadena".replace("a", "A", 1)  # Retorna 'CAdena'

				Nota: "<subcadena>" y "<nuevaSubcadena>"" pueden ser una expresión.

		Diccionarios:
			. Buscar clave:
				<diccionario>.has_key(<clave>)  # Retorna verdadero o falso dependiendo de si encuentra la clave en el diccionario
				<clave> in <diccionario>  # Retorna verdadero o falso dependiendo de si encuentra la clave en el diccionario

				Nota: "<clave>" puede ser una expresión.

			· Clonar:
				<diccionario>.copy()

			· Concatenar diccionario:
				<diccionario>.update(<otroDiccionario>)

			· Crear diccionario en base a un iterable:
				<identificador> = dict.fromkeys(<iterable>[, <valorPredeterminado>])

				Nota: Si no se especifica "<valorPredeterminado>" los valores de todas las claves serán "None".

			· Eliminar clave:
				<diccionario>.pop(<clave>[, <valorPredefinido>])

				Notas:
					· "<clave>" y "<valorPredefinido>" pueden ser una expresión.
					· Retorna el valor de la clave eliminada, si no existe retornará "<valorPredefinido>" o si no se definió generará un error.
					· También puede eliminarse una clave específica del diccionario con la función "del(<diccionario>[<clave>])".

			. Obtener claves:
				<diccionario>.keys()  # Retorna una lista con las claves del diccionario

			· Obtener diccionario como lista:
				<diccionario>.items()  # Retorna una lista con cada par (clave, valor) como tupla

				Ejemplo:
					diccionario.items()  # Retorna [('Clave 2', 2), ('Clave 3', 3.0), ('Clave 1', 'Valor 1')]

			· Obtener valor de una clave:
				<diccionario>.get(<clave>, <valorPredefinido>)

				Notas:
					· Es equivalente a usar "<diccionario>[<clave>]", pero en caso de no encotrar la clave retornará "<valorPredefinido>".
					· "<clave>" y "<valorPredefinido>" pueden ser una expresión.

			. Obtener valores:
				<diccionario>.values()  # Retorna una lista con los valores del diccionario

			· Vaciar:
				<diccionario>.clear()  # No es equivalente a "del()" porque solo vacía el diccionario

		Listas:
			· Agregar elemento:
				<lista>.insert(<índice>, <valor>)

				Notas:
					· Si "<índice>" existe, moverá una posición todos los elementos delante de el.
					· "<índice>" y "<valor>" puede ser una expresión.

			· Agregar elemento al final de la lista:
				<lista>.append(<valor>)

				Nota: "<valor>" puede ser una expresión.

			· Concatenar listas:
				<lista>.extend(<iterable>)
				<lista> += <iterable>

				Nota: Si se concatena un diccionario con una lista, se agregarán sus claves y no sus valores.

			· Buscar valor:
				<lista>.index(<valor>[, <índiceInicial>[, <índiceFinal+1>]])  # Retorna el índice de la primera coincidencia
				<valor> in lista  # Retorna verdadero o falso dependiendo de si encuentra el valor dentro de la lista

				Nota: "<valor>" puede ser una expresión.

			· Vaciar:
				<lista>.clear()  # No es equivalente a "del()" porque solo vacía la lista
				del <lista>[:]

			· Veces que aparece el valor especificado:
				<lista>.count(<valor>)

				Nota: "<valor>" puede ser una expresión.

			· Eliminar índice:
				<lista>.pop([<índice>])

				Notas:
					· Retorna el valor del índice eliminado.
					· "<índice>" puede ser una expresión.
					· Si no se especifica "<índice>", se toma el último elemento.
					· También puede eliminarse un índice específico de la lista con la función "del(<lista>[<índice>])".

			· Eliminar valor:
				<lista>.remove(<valor>) # Solo elimina la primera coincidencia

				Nota: "<valor>" puede ser una expresión.

			· Invertir lista:
				<lista>.reverse()

			· Ordenar lista:
				<lista>.sort([reverse = True])

		Tuplas:
			· Buscar valor:
				<tupla>.index(<valor>[, <índiceInicial>[, <índiceFinal+1>]])  # Retorna el índice de la primera coincidencia
				<valor> in tupla # Retorna verdadero o falso dependiendo de si encuentra el valor dentro de la tupla

				Nota: "<valor>" puede ser una expresión.

			· Veces que aparece el valor especificado:
				<tupla>.count(<valor>)

				Nota: "<valor>" puede ser una expresión.

		Conjuntos:
			· Agregar elemento:
				<conjunto>.add(<expresión>)

			· Clonar:
				<conjunto>.copy()

			· Determinar si los conjuntos no tienen elementos en común:
				<conjunto>.isdisjoint(<iterable>)

			· Determinar si un conjunto es subconjunto de otro
				<subconjunto>.issubset(<conjunto>)
				<subconjunto> <= <conjunto>
				<subconjunto> < <conjunto>  # Retorna verdadero si es subconjunto y no es igual

				<conjunto>.issuperset(<subconjunto>)
				<conjunto> >= <subconjunto>
				<conjunto> > <subconjunto>  # Retorna verdadero si es subconjunto y no es igual

			· Diferencia:
				<conjunto>.difference(<iterable>[, ...])
				<conjunto> - <otroConjunto> [- ...]

				Para que se guarde la diferencia en <conjunto>:

				<conjunto>.difference_update(<iterable>[, ...])
				<conjunto> -= <otroConjunto> [| ...]

			· Diferencia simétrica:
				<conjunto>.symmetric_difference(<iterable>)
				<conjunto> ^ <otroConjunto>

				Para que se guarde la diferencia simétrica en <conjunto>:

				<conjunto>.symmetric_difference_update(<iterable>)
				<conjunto> ^= <otroConjunto>

			· Eliminar elemento:
				<conjunto>.remove(<expresión>)  # Genera error si no existe <expresión>
				<conjunto>.discard(<expresión>)

			· Intersección:
				<conjunto>.intersection(<iterable>[, ...])
				<conjunto> & <otroConjunto> [& ...]

				Para que se guarde la intersección en <conjunto>:

				<conjunto>.intersection_update(<iterable>[, ...])
				<conjunto> &= <otroConjunto> [& ...]

			· Unión:
				<conjunto>.union(<iterable>[, ...])
				<conjunto> | <otroConjunto> [| ...]

				Para que se guarde la unión en <conjunto>:

				<conjunto>.update(<iterable>[, ...])
				<conjunto> |= <otroConjunto> [| ...]

			· Vaciar:
				<conjunto>.clear()

Manejo de archivos:
	<variable> = open(<archivo>[, <modo>][, encoding = <codificación>])  # Crea un objeto del tipo file

	Los objetos creados usan un puntero para leer y escribir el contenido de los archivos, este puntero contiene el byte en el que esta posicionado y apartir de él se realizarán todas las tareas.

	Modos:
		· x: Creación.
			Genera error si ya existe.
			Agregado en Python 3.
		· r: Lectura.
			Posiciona el puntero en el byte 0.
			Genera error si no existe el archivo.
		· w: Escritura.
			Posiciona el puntero en el byte 0.
			Si el arhivo existe, borra su contenido y si no, lo crea.
		· a: Adición.
			Posiciona el puntero en el último byte.
			Siempre escribe al final del contenido, sin importar donde esté el puntero.
			Si el archivo existe, mantiene su contenido y si no, lo crea.
		· r+: Lectura y escritura.
			Posiciona el puntero en el byte 0.
			Mientras no se mueva el puntero con ".seek()", escribe al final del contenido.
			Si se mueve el puntero con ".seek()", se remplazarán los bytes del contenido por los nuevos al momento de escribir.
			Genera error si no existe.
		· w+: Lectura y escritura.
			Posiciona el puntero en el byte 0.
			Si el arhivo existe, borra su contenido y si no, lo crea.
		· a+: Lectura y adición.
			En Python 2, posiciona el puntero en el byte 0.
			En Python 3, posiciona el puntero en el último byte.
			Siempre escribe al final del contenido, sin importar donde esté el puntero.
			Si el archivo existe, mantiene su contenido y si no, lo crea.

	Métodos:
		· Puntero:
			<archivo>.tell()  # Retorna el byte actual del puntero
			<archivo>.seek(<byte>)  # Mueve el puntero al byte especificado

		· Lectura:
			<archivo>.read([<bytes>])  # Retorna "<bytes>" bytes desde la posición del puntero o hasta el final si no se especifica
			<archivo>.readline([<bytes>])  # Retorna "<bytes>" bytes desde la posición del puntero o hasta el final de la línea si no se especifica (incluyendo el salto de línea)
			<archivo>.readlines()  # Retorna una lista con las líneas desde la posición del puntero.

		· Escritura:
			<archivo>.write(<cadena>)  # Los bytes a partir del puntero se remplazan por los nuevos
			<archivo>.writelines(<iterable>)  # Los bytes a partir del puntero se remplazan por los nuevos, <iterable> debe contener cadenas y no se agregan automáticamente los saltos de línea

		· Cerrar:
			<archivo>.close()  # Termina la manipulación del archivo

	Atributos:
		· closed: Permite saber si el archivo ha sido cerrado.
		· encoding: Contiene la codificación del archivo.
		· mode: Contiene el modo con el que se abrió el archivo.
		· name: Contiene el nombre del archivo.

	Estructura "with":
		with open(<archivo>[, <modo>][, encoding = <codificación>]) as <variable>:
			<sentencias>

		Nota: Cierra el objeto cuando termine de ejecutar sus sentencias, es posible usar esta estructura con objetos de conexión a bases de datos y sus cursores.

Progración modular:
	import [<carpeta>.[<subcarpeta>.[...]]]<archivo>[ as <nuevoNombre>][, ...]  # Sin extensión y debe estar en la misma carpeta o en subcarpetas de la ubicación del script

	<archivo>.<variable>  # Es posible acceder al namespace del módulo que se importa anteponiendo su nombre a las variables, funciones, clases, etc...
	<archivo>.<función>
	<archivo>.<clase>

	Ejemplo:
		Archivo 1:
			import prueba

			prueba.alerta(prueba.variable)

		Archivo 2 (prueba.py):
			def alerta(mensaje):
				print(mensaje)

			variable = "Mensaje de prueba"

	Ejemplo con paquetes (carpetas):
		Archivo 1:
			import paquete.prueba

			paquete.prueba.alerta(paquete.prueba.variable)

		Archivo 2 (paquete/prueba.py):
			def alerta(mensaje):
				print(mensaje)

			variable = "Mensaje de prueba"

			Notas:
				· Para que una carpeta sea considerada un paquete debe contener un archivo "__init__.py" sin importar que esté vacío.

	También es posible importar solo algunos elementos y agregarlos directamente en el namespace del script local usando la sintaxis:
		from [<carpeta>.[<subcarpeta>.[...]]]<archivo> import * | <elemento>[ as <nuevoNombre>][, ...]

		Nota: "*" agregará todos los elementos al namespace del script local.

		Archivo 1:
			from prueba import *

			alerta(variable)

		Archivo 2 (prueba.py):
			def alerta(mensaje):
				print(mensaje)

			variable = "Mensaje de prueba"

	Notas:
		· Es posible hacer que Python lea paquetes/módulos de un repositorio personalizado, se puede hacer de dos formas:
			· Temporal (mientras dure la ejecucón del Script):
				import sys

				sys.path.append("<rutaAlRepositorio>")  # El repositorio no necesita el archivo "__init__.py", pero sus subcarpetas sí.

			· Permanente:
				Se debe agregar la ruta del repositorio a la variable de entorno "PYTHONPATH" directamente en el SHELL del sistema operativo.
					export PYTHONPATH=$PYTHONPATH:<rutaAlRepositorio>[:<rutaOtroRepositorio>]

		· Todas las sentencias dentro de los módulos importados serán ejecutadas.
		· Si se quiere usar el módulo como un script (python | python3 <módulo> <parámetro>[ ...]) y solo es necesario que ejecuten ciertas sentencias, se debe crear la siguiente condición:
			Archivo 2 (prueba.py):
				def alerta(mensaje):
					print(mensaje)

				if __name__ == "__main__":
					# Solo se ejecutaran las sentencias si se llama al modulo como un script

					import sys  # Esta biblioteca permite acceder a los parámetros que se usaron al llamar al modulo

					alerta("El modulo se ejecuto como script con los parámetros " + str(sys.argv))

					# El parámetro sys.argv[0] siempre sera la ruta con la que fue ejecutado el modulo

				else:
					alerta("El modulo se invoco con import o from-import")

		· Lo módulos importados también usan Docstings. Ejemplo:
			Archivo 1:
				import prueba

				prueba.alerta(prueba.__doc__)

			Archivo 2 (prueba.py):
				"""Docstring

					También es posible usar Docstrings en los módulos
				"""

				def alerta(mensaje):
					print(mensaje)

		· El estandar de importación dicta las siguientes normas:
			· La importación debe estar entre las primeras líneas del script.
			· Los paquetes/módulos deben estar organizados alfabéticamente.
			· La importación tiene tres secciones:
				<paquetes/módulos de Python>
				# Una línea vacía
				<paquetes/módulos de herramientas externas>
				# Una línea vacía
				<paquetes/módulos propios>

	Módulos predefinidos:
		· Expresiones regulares (re):
			· Buscar coincidencias:
				re.search(<patrón>, <cadena>[, flags = <bandera>])  # Retorna un MatchObject
				re.findall(<patrón>, <cadena>[, flags = <bandera>])  # Retorna una lista con las coincidencias
				re.finditer(<patrón>, <cadena>[, flags = <bandera>])  # Retorna un iterador que contiene cada coincidencia como un MatchObject

			· Comprobar patrón:
				re.match(<patrón>, <cadena>[, flags = <bandera>])  # Comprueba el início de la cadena. . Retorna un MatchObject
				re.fullmatch(<patrón>, <cadena>[, flags = <bandera>])  # Comprueba toda la cadena, agregado en Python 3. Retorna un MatchObject

			· Dividir por medio de patrones:
				re.split(<patrón>, <cadena>[, <veces>][, flags = <bandera>])  # Retorna una lista

				Nota: Si se usan grupos (patrones con parentesis), estos aparecerán en la lista

			· Sustituir:
				re.sub(<patrón>, <nuevaSubcadena>, <cadena>[, <veces>][, flags = <bandera>])  # Retorna una cadena con los cambios
				re.subn(<patrón>, <nuevaSubcadena>, <cadena>[, <veces>][, flags = <bandera>])  # Retorna una lista el primer elemento es la cadena con los cambios y el segundo es la cantidad de veces que se cambio el patrón.

				Nota: Apartir de Python 3.6 se eliminará ".sub()" pues ".subn()" tiene la misma función pero presenta algunas mejoras.

			Si se va a utilizar un patrón repetidas veces, es recomendable crear un RegexObject con él para mejorar su rendimiento:
				<variable> = re.compile(<patrón>[, flags = <bandera>])
				<variable>.<método>

				Atributos del RegexObject:
					· flags: Bandera usada en la creación.
					· groups: Cantidad de grupos (patrones con parentesis).
					· pattern: Patrón con el que se creó el RegexObject.

				Métodos del RegexObject:
					Se comportan igual que las funciones anteriores pero tienen pequeños cambios de sintaxis.

					· Buscar coincidencias:
						search(<cadena>[, <índiceInicial>[, <índiceFinal + 1>]])
						findall(<cadena>[, <índiceInicial>[, <índiceFinal + 1>]])
						finditer(<cadena>[, <índiceInicial>[, <índiceFinal + 1>]])

					· Comprobar patrón:
						match(<cadena>[, <índiceInicial>[, <índiceFinal + 1>]])
						fullmatch(<cadena>[, <índiceInicial>[, <índiceFinal + 1>]])

					· Dividir por medio de patrones:
						split(<cadena>[, <veces>])

					· Sustituir:
						sub(<nuevaSubcadena>, <cadena>[, <veces>])
						subn(<nuevaSubcadena>, <cadena>[, <veces>])

			Atributos del MatcObject:
				· pos: Parámetro "<índiceInicial>" si se uso con un RegexObject.
				· endpos: Parámetro "<índiceFinal + 1>" si se uso con un RegexObject.
				· string: Párametro "<cadena>".

			Métodos del MatchObject:
				· start(): Retorna el índice en el que inicia la coincidencia.
				· end(): Retorna el índice en el que termina la coincidencia.
				· group([<índice>[, ...]]): Retorna el grupo en "<índice>", 0 o nada será la coincidencia completa y de 1 en adelante todos los grupos (patrones con parentesis).
				· groups(): Retorna una tupla con los grupos.

Excepciones:
	try:
		<sentencias>

	except[ <excepción>[as <objeto>] | ( <excepción>[as <objeto>], ...)]:
		<sentecias>

	[except[ <excepción>[as <objeto>] | ( <excepción>[as <objeto>], ...)]:
		<sentencias>]

	[else:
		# Se ejecuta solo si no ocurrió una excepción
		<sentencias>]

	[finally:
		# Siempre se ejecuta, sin importar que ocurran excepciones
		<sentencias>]

	Ejemplo:
		try:
			n1 = int(input("Suma:\nIngrese el primer numero: "))
			n2 = int(input("Ingrese el segundo numero: "))

			print(n1 + n2)

		except ValueError:
			print("Debe igresar solo numeros")

		except:
			print("Ocurrio un error!")

		else:
			print("Muy bien, se ejecuto todo sin errores")

		finally:
			print("Gracias por usar este programa")

	Es posible generar excepciones instanciando la clase "Exception"
		try:
			<sentencias>
			raise Exception(<parámetro>[, ...])

		except Exception as <objeto>:
			print(<objeto>)  # Muestra el valor retornado por <objeto>.__str__()
			print(<objeto>.args)  # Muestra los parámetros usados para instanciar "Exception"

		Ejemplo:
			try:
				n = input("Ingrese un numero: ")

				if int(n) < 5:
					print("Bien, muchas gracias")

				else:
					raise Exception("El numero es muy grande")

			except Exception as mensaje:
				print(mensaje)

	O creando una clase que herede de "Exception":
		class <nombre>(Exception):
			def __init__(self[, <parámetro>[, ...]]):
				<sentencias>

			def __str__(self):
				<sentencias>
				return <mensaje>

		try:
			<sentencias>
			raise <nombre>(<parámetro>[, ...])

		except <nombre> as <objeto>:
			print(<objeto>)  # Muestra el valor retornado por <objeto>.__str__()
			print(<objeto>.args)  # Muestra los parámetros usados para instanciar "<nombre>"

		Ejemplo:
			class Prueba(Exception):
				def __init__(self, mensaje):
					self.mensaje = mensaje

				def __str__(self):
					return self.mensaje

			try:
				n = input("Ingrese un numero: ")

				if int(n) < 5:
					print("Bien, muchas gracias")

				else:
					raise Prueba("El numero es muy grande")

			except Prueba as mensaje:
				print(mensaje)

	Existe una palabra clave llamada `assert`, en caso de que la primera expresión que la acompañe sea evaluada como `False`, se levantará una excepción de tipo `AssertionError`, la segunda expresión (si existe) será el mensaje que la acompañe:

		assert <expresión>[, <mensaje>]

Almacenamiento:
	· Archivos:
		· Binarios:
			Rápida lectura y escritura pero solo compatible con Python. Permite serializar la mayoría de los objetos, incluyendo los definidos por el programador. Necesita que los archivos usados se abran en modo binario.

			Ejemplo:
				import pickle

				with open("data.dat", "wb+") as archivo:
					variable = "Hola"
					otraVariable = 11

					print(variable, otraVariable)

					pickle.dump(variable, archivo)
					pickle.dump(otraVariable, archivo)

					archivo.seek(0)

					otraVariable = pickle.load(archivo)
					variable = pickle.load(archivo)

					print(variable, otraVariable)

			Notas: ".dumb()" necesita que el objeto del archivo soporte escritura y ".load()" que soporte lectura.

	· Bases de datos:
		Python posee un estándar llamado "DB-API" que permite trabajar con diferentes sistemas gestores de bases de datos usando las mismas sentencias.

		Variables globales:
			· <módulo>.apilevel: Versión de DB-API con la que trabaja el módulo.
			· <módulo>.paramstyle: Técnica para tratar las cadenas SQL, existen:
				· pyformat: Usa "%(<clave>)<formato>" para sustituir.
					<cursor>.execute("select * from <tabla> where <campo> = %(<clave>)<formato>", <diccionario>)

					Ejemplo:
						cursor.execute("select * from anime where nombre = %(nombre)s", {"nombre": "One Piece"})

				· qmark: Usa "?" para sustituir.
					<cursor>.execute("select * from <tabla> where <campo> = ?", <iterable>)

					Ejemplo:
						cursor.execute("select * from anime where nombre = ?", ("One Piece",))

		Objetos:
			· Conexión:
				<identificador> = <módulo>.connect()

				Métodos:
					· commit(): Confirma los cambios realizados.
					· rollback(): Deshace los cambios realizados.
					· close(): Cierra la conexión.

			· Cursor: Permiten realizar consultas a la BD.
				<identificador> = <conexión>.cursor()

				Nota: Los cursores creados con una misma conexión no necesitarán confirmar los cambios para verlos entre sí.

				Atributos:
					· arraysize: Cantidad predefinida de registros obtenidos por "fetchmany()", su valor inicial es "1".
					· description: Contiene una lista con los campos de la base de datos obtenidos de la última consulta y algunos datos que los describen.
					· rowcount: Cantidad de registros afectados por la última consulta.
					· lastrowid: Contiene el valor del campo autoincrementable (si la tabla lo tiene) al ingresar un registro, depende del gestor de bases de datos.

				Métodos:
					· execute("<sql>"[, <iterable>]): Ejecuta una consulta. Ejemplo:
						cursor.execute("insert into anime values(?, ?)", ('One Piece', 722))
						cursor.execute("insert into anime values(?, ?)", ('Psycho Pass', 24))

					· executemany("<sql>"[, <iterable>]): Ejecuta una consulta repetidas veces según la cantidad de iterables dentro de <iterable>. Ejemplo:
						animes = (
							('One Piece', 722),
							('Rurouni Kenshin', 95),
							('Fate', 24),
							('Naruto', 600),
							('Dragon Ball', 95),
							('Psycho Pass', 24)
						)

						cursor.executemany("insert into anime values(?, ?)", animes)

						Nota: No soporta "select".

					· fetchone(): Retorna como una tupla un registro del resultado obtenido de una consulta, si no existen más registros retornará "None".
					· fetchmany([<cantidad>]): Retorna una lista con la cantidad de registros especificados, si no se pasa ninguna cantidad se usará el atributo "arraysize" del cursor.
					· fetchall(): Retorna una lista con los registros obtenidos de la consulta.
					· close(): Cierra el cursor.

		Constructores de tipos de datos:
			· <módulo>.Date(<año>, <mes>, <día>): Fecha.
			· <módulo>.Time([<hora>[, <minuto>[, <segundo>]]]): Hora.
			· <módulo>.Timestamp(<año>, <mes>, <día>[, <hora>[, <minuto>[, <segundo>]]]): Hora.
			· <módulo>.DateFromTicks(<segundos>): Fecha a partir de segundos transcurridos desde 1970.
			· <módulo>.TimeFromTicks(<segundos>): Hora a partir de segundos transcurridos desde 1970.
			· <módulo>.TimestampFromTicks(<segundos>): Fecha y hora a partir de segundos transcurridos desde 1970.
			· <módulo>.BINARY(<cadena>): Datos binarios.

		DBMS:
			· MySQL:
				Instalación:
					1. Descargar alguna versión del conector (https://pypi.python.org/pypi/mysql-connector-python)
					2. Descomprimir el conector:
						$ unzip mysql-connector-python-<versión>.zip
					3. Ejecutar el instalador:
						$ cd mysql-connector-python-<versión>
						# <interprete Python> setup.py install

				import mysql.connector

				Apilevel: 2.0
				Paramstyle: pyformat

				Variables globales:
					<módulo>.__version__: Versión del conector.

				Objetos:
					· Conexión:
						<identificador> = mysql.connector.connect(user = "<usuario>", password = "<contraseña>", database = "<base de datos>"[, host = "<host>"][, port = "<puerto>"][, autocommit = True | False][, connection_timeout = "<tiempo límite>"][, buffered = True | False])

							Parámetros:
								· host: Su valor predeterminado es "127.0.0.1", lo que es igual a "localhost".
								· port: Su valor predeterminado es "3306".
								· autocommit: Su valor predeterminado es "False".
								· connection_timeout: Tiempo límite en segundos de intentos de conexión.
								· buffered: Su valor predeterminado es "False", si alguno de los cursores de una misma conexión retorna registros y no se obtienen todos (fetchall()) antes de realizar otra consulta que dependa de los datos obtenidos, se generará un error, para evitarlo se puede establecer este parámetro como "True" y así todos los cursores de la conexión obtendran los registros automaticamente al ejecutar la consulta.

						Métodos:
							· config(<parámetros>): Permite reconfigurar una conexión ya inicializada, para aplicar los cambios se debe reiniciar la conexión con el método "reconnect()".
							· is_connected(): Verifica que la conexión está activa.
							· reconnect([attempts = <intentos>][, delay = <intervalo en segudos>]): Reinicia la conexión.

						Atributos:
							· autocommit: Permite establecer la opción de autoconfirmación.
							· in_transaction: Estado de transacción.

					· Cursor:
						<identificador> = <conexión>.cursor([dictionary = True | named_tuple = True][, buffered = True][, raw = True])

							Parámetros:
								· dictionary: Los registros se obtienen como un diccionario en lugar de una tupla.
								· named_tuple: Los registros se obtienen como un objeto en lugar de una tupla.
								· buffered: Su valor predeterminado es "False", si alguno de los cursores de una misma conexión retorna registros y no se obtienen todos (fetchall()) antes de realizar otra consulta que dependa de los datos obtenidos, se generará un error, para evitarlo se puede establecer este parámetro como "True" y así el cursor obtendra los registros automaticamente al ejecutar la consulta.
								· raw: Evita que los datos se conviertan de MySQL a Python.

						Métodos:
							· execute("<sql>"[, <iterable>][, multi = True]): Ejecuta una o varias (usando "multi") consultas, retorna un iterador con los resultados de las consultas ejecutadas si se usó el parámetro "multi". Ejemplo:
								cursor.execute("select * from anime")
								cursor.execute("select * from anime where nombre = %(nombre)s; select * from anime where nombre = %(nombre2)s", {"nombre": "One Piece", "nombre2": "Rurouni Kenshin"}, multi = True)

						Atributos:
							· with_rows: Retorna verdadero si la consulta retorna registros.

				Técnicas de consultas anidadas:
					Ambos métodos consumen casi la misma cantidad de recursos, su uso dependerá de los gustos de cada programador.

					· Usando buffered cursors:
						import mysql.connector as db

						conexion = db.connect(user = "root", password = "root", database = "UCI")
						cursor = conexion.cursor(buffered = True)
						cursor2 = conexion.cursor()

						cursor.execute("select * from cama")

						for registro in cursor:
							cursor2.execute("select * from cama where nc = %(nc)s", {"nc": registro[0]})

							print(cursor2.fetchone())

						cursor2.close()
						cursor.close()
						conexion.close()

					· Obteniendo datos del cursor:
						import mysql.connector as db

						conexion = db.connect(user = "root", password = "root", database = "UCI")
						cursor = conexion.cursor()

						cursor.execute("select * from cama")

						for registro in cursor.fetchall():  # Obtener todos los registros
							cursor.execute("select * from cama where nc = %(nc)s", {"nc": registro[0]})

							print(cursor.fetchone())

						cursor.close()
						conexion.close()

			· PostgreSQL:
				Instalación:
					1. Instalar el cliente de PostgreSQL de C
						# apt-get install libpq5 libpq-dev

					2. Instalar Psycopg:
						# <instancia de pip> install psycopg2

				import psycopg2

				Apilevel: 2.0
				Paramstyle: pyformat

				Objetos:
					· Conexión:
						<identificador> = psycopg2.connect(user = "<usuario>", password = "<contraseña>", database = "<base de datos>", host = "<host>"[, port = "<puerto>"][, connection_timeout = "<tiempo límite>"][, cursor_factory = <clase personalizada>])

							Parámetros:
								· port: Su valor predeterminado es "5432".
								· connection_timeout: Tiempo límite en segundos de intentos de conexión.
								· cursor_factory: Permite usar una clase personalizada para los cursores de la conexión. Psycopg proporciona algunas predefinidas, pero hay que importarlas desde el módulo "psycopg2.extras":
									· psycopg2.extras.DictCursor: Retorna los registros como objetos que tienen la posibilidad de acceder a sus valores con índices o claves.
									· psycopg2.extras.NamedTupleCursor: Retorna los registros como objetos que tienen la posibilidad de acceder a sus valores como si fuesen atributos.

						Atributos:
							· autocommit: Retorna "True" si está activa la autoconfirmación y "False" en caso contrario, puede modificarse.
							· closed: Retorna 0 si la conexión está activa o algún número si no.
							· server_version: Versión de PostgreSQL, cambia los "." por "0", ejemplo: 9.4.4 -> 90404.

						Métodos:
							· cancel(): Cancela la consulta que se esté ejecutando.
							· set_session([isolation_level = <nivel de aislamiento>][, readonly = True][, autocommit = True]): Modifica los valores de configuración de la sesión.

								Parámetros:
									· isolation_level: Nivel de aislamiento.
									· readonly: Solo lectura.
									· autocommit: Autoconfirmar los cambios que se realicen.

							· reset(): Deshace los cambios en la transacción y establece los valores predeterminados de la sesión al crearse.

					· Cursor:
						<identificador> = <conexión>.cursor([name = "<nombre>"][, cursor_factory = <clase personalizada>])

							Parámetros:
								· name: Habilita las opciones "scrollable" y "withhold", respectivamente, permiten navegar entre los datos consultados por el cursor con el método "scroll()" y obtener datos después de haber confirmado la transación, pero no después de deshacerla.
								· cursor_factory: Permite usar una clase personalizada para generar el cursor. Psycopg proporciana algunas predefinidas, pero hay que importarlas desde el módulo "psycopg2.extras":
									· psycopg2.extras.DictCursor: Retorna los registros como objetos que tienen la posibilidad de acceder a sus valores con índices o claves.
									· psycopg2.extras.NamedTupleCursor: Retorna los registros como objetos que tienen la posibilidad de acceder a sus valores como si fuesen atributos.

						Atributos:
							· connection: Retorna una referencia al objeto de la conexión.
							· scrollable: Retorna "True" si el cursor tiene la propiedad "scrollable" o "False" si no, puede modificarse.
							· withhold: Retorna "True" si el cursor tiene la propiedad "withhold" o "False" si no, puede modificarse.
							· rownumber: Retorna el índice actual del cursor.
							· query: Contiene la consulta ejecutada con los parámetros transformados.
							· statusmessage: Retorna el mensaje obtenido de PostgreSQL despues de ejecutar una consulta.
							· closed: Retorna "True" si el cursor está cerrado o "False" si no.

						Métodos:
							· scroll(<posición>, mode = "absolute"): Navegar entre los registros obtenidos por el cursor:
								cursor.fetchone()  # Retorna el registro 1
								cursor.(0, "absolute")  # Cursor en el inicio
								cursor.fetchone()  # Retorna el registro 1
								cursor.(4, "absolute")  # Cursor en 4 registro
								cursor.fetchone()  # Retorna el registro 5

							· mogrify("<sql>"[, <iterable>]): Permite previsualizar una consulta despues de ser transformada, ejemplo:
								cursor.mogrify("select * from anime where nombre = %(nombre)s", {"nombre": "One Piece"})

								# Retorna:
								#	select * from anime where nombre = 'One Piece'

							· copy_to(<objeto de archivo>, "<tabla>"[, sep = "<separador de valores>"][, null = "<valor que represente NULL>"][, columns = <iterable con el nombre de los campos a copiar>]): Permite copiar el contenido de una tabla en un archivo.

								Parmametros:
									· sep: Su valor predeterminado es "\t".
									· null: Su valor predeterminado es "\\N".

							· copy_from(<objeto de archivo>, "<tabla>"[, sep = "<separador de valores>"][, null = "<valor que represente NULL>"][, size = <tamaño del buffer>][, columns = <iterable con el nombre de los campos en los que se copiará>]): Permite copiar datos de un archivo a una tabla.

								Parmametros:
									· sep: Su valor predeterminado es "\t".
									· null: Su valor predeterminado es "\\N".
									· size: Su valor predeterminado es 8192.

			· SQLite:
				import sqlite3

				Apilevel: 2.0
				Paramstyle: qmark

				Variables globales:
					· <módulo>.version: Versión del módulo
					· <módulo>.sqlite_version: Versión de SQLite

				Objetos:
					· Conexión:
						<identificador> = sqlite3.connect("<archivo> | :memory:"[, timeout = <tiempo límite>][, isolation_level = <nivel de aislamiento>][, uri = True | False])

							Parámetros:
								· timeout: Tiempo límite en segundos de intentos de conexión.
								· isolation_level: Nivel de aislamiento de las transacciones. Valores:
									· None: Guarda automáticamente todos los cambios.
								· uri: Su valor predefindo es "False", en caso contrario permite establecer opciones para abrir la base de datos, por ejemplo abrirla en modo de solo lectura:
									sqlite3.connect("file:data.dat?mode=ro", uri = True)

							Nota: ":memory:" permite montar la base de datos en la RAM y no en algún archivo.

						Atributos:
							· isolation_level: Nivel de aislamiento, puede modificarse.
							· in_transaction: Estado de transacción.
							· row_factory: Permite agregar funcionalidades a los resultados obtenidos por las consultas, existe una clase predefinida en el módulo:
								conexion.row_factory = sqlite3.Row

								for registro in cursor.execute("select * from anime"):
									print(registro["nombre"])

								Notas:
									· Permite usar los nombres de los campos como claves de un diccionario.
									· Al usarse "registro" como iterable se retornarán sus valores y no sus claves, lo que lo hace diferente de un diccionario, ejemplo:
										for registro in cursor.execute("select * from anime"):
											for campo in registro:
												print(campo)

							· total_changes: Cantidad de registros afectados por las consultas realizadas con cursores de la conexión.

						Métodos:
							· execute("<sql>"[, <iterable>]): Retorna un objeto cursor y ejecuta su método "execute()".
							· executemany("<sql>"[, <iterable>]): Retorna un objeto cursor y ejecuta su método "executemany()".
							· executescript("<sql>; <sql>[; ...]"): Permite ejecutar varias consultas separadas por ";".
							· create_function("<nombre>", <cantidad de parámetros>, <función>): Crear una función para utilizarla directamente en SQL, ejemplo:
								def mitad(n):
									return n // 2

								conexion.create_function("mitad", 1, mitad)
								conexion.execute("select mitad(episodios) from anime")

							· interrupt(): Interrumpe todas las consultas que se estén ejecutando en cualquier cursor del objeto de la conexión.
							· iterdump(): Obtiene un iterador con la base de datos línea a línea en formato SQL.

					· Cursor:
						Métodos:
							· executescript("<sql>; <sql>[; ...]"): Permite ejecutar varias consultas separadas por ";".

Aplicaciones Web:
	Python usa WSGI para trabajar con aplicaciones web, son servidas mediante un controlador principal (patrón de diseño Front Controller) y por esto se deben respetar algunas reglas cuando se programa. El controlador debe contener como mínimo la siguiente estructura:

		def application(environ, start_response):
			start_response("<código de estado>", [("Content-Type", "<MIME Type>; charset=<codificación>")])
			return [bytes(<repuesta>, "<codificación>")]

	La función "application" se encargará de controlar las peticiones que lleguen a la aplicación y deberá generar una respuesta HTTP válida, para esto usa la función "start_response" y el valor de retorno, que debe ser una lista que contenga valores binarios (por eso la función "bytes()"); además está el diccionario "environ" que contiene variables útiles para los servicios web. Un ejemplo sencillo:

		def application(environ, start_response):
			start_response("200 OK", [("Content-Type", "text/html; charset=utf-8")])
			return [bytes("Hola", "utf-8")]

	Para poder servir la aplicación es necesario habilitar un servicio WSGI con las bibliotecas predefinidas de Python o programas de algún tercero:
		· Bibliotecas de Python:
			from wsgiref.simple_server import make_server

			def application(environ, start_response):
				start_response("200 OK", [("Content-Type", "text/html; charset=utf-8")])
				return [bytes("Hola", "utf-8")]

			puerto = 4000
			make_server("", puerto, application).serve_forever()  # Accesible desde localhost:4000

		· uWSGI (Recomendado):
			Instalación:
				<instancia de pip> install uwsgi

			Uso:
				prueba.py:
					def application(environ, start_response):
						start_response("200 OK", [("Content-Type", "text/html; charset=utf-8")])
						return [bytes("Hola", "utf-8")]

				$ uwsgi --http :4000 [--chdir=<ruta al proyecto>] --wsgi-file prueba.py

			Servidor Web (NGINX):
				$ uwsgi --http-socket :<puerto> --chdir=<ruta al proyecto> --wsgi-file <script WSGI>

				Archivo de configuración para NGINX:
					proxy_cache_path /tmp keys_zone=<nombre de la zona de cache>:10m max_size=256 inactive=12h;

					server {
						listen <puerto>;
						listen [::]:<puerto> ipv6only=on;

						server_name <nombre del sitio>;
						root <ruta de la carpeta del sitio>;
						charset utf-8;

						# Configuración de cache recomendada por H5BP con algunos arreglos

						location ~* \.(?:manifest|appcache|html?|xml|json)$ {
							expires 1M;
							add_header Cache-Control "public";
						}

						location ~* \.(?:rss|atom)$ {
							expires 1h;
							add_header Cache-Control "public";
						}

						location ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ {
							expires 1M;
							add_header Cache-Control "public";
						}

						location ~* \.(?:css|js)$ {
							expires 1M;
							add_header Cache-Control "public";
						}

						location ~* \.(?:ttf|ttc|otf|eot|woff|woff2)$ {
							expires 1M;
							add_header Cache-Control "public";
						}

						# ------------------------------------------

						location / {
							proxy_cache <nombre de la zona de cache>;
							include proxy_params;
							proxy_pass <URI del socket>;
						}
					}

					Nota: Esta configuración servirá el contenido estático directamente y no usará el controlador para esos casos, si se quiere evitar esto, se debe eliminar "|html?" de la línea "location ~* \.(?:manifest|appcache|html?|xml|json)$ {".

	Variables contenidas en "environ":
		HTTP_ACCEPT: Tipo de datos compatible para la respuesta.
		HTTP_ACCEPT_ENCODING: Tipo de compresión compatible para la respuesta.
		HTTP_ACCEPT_LANGUAGE: Lenguaje del cliente.
		HTTP_HOST: Dominio y puerto del servidor.
		HTTP_USER_AGENT: Información sobre el dispositivo y el navegador del cliente.
		PATH_INFO: Ruta después del dominio y antes del "?".
		QUERY_STRING: Ruta después del "?", variable pasadas por GET.
		REMOTE_ADDR: IP del cliente.
		REQUEST_METHOD: Método HTTP.
		REQUEST_URI: Ruta después del dominio.
		SCRIPT_NAME: Ubicación del script WGSI en caso de que no sea la ruta principal.
		SERVER_NAME: Nombre de host del servidor.
		SERVER_PORT: Puerto del servidor.
		SERVER_PROTOCOL: Versión del protocolo HTTP del servidor.

Correo electrónico:




Cadenas Unicode
Minileguaje de formato (format()) - https://docs.python.org/3/library/string.html#string-formatting
Negar binarios (complemento a dos)
Lista de excepciones predefinidas: https://docs.python.org/3.5/library/exceptions.html#bltin-exceptions
Flags de expresiones regulares



Referencias:
	Raúl Gonzáles Duque. Python para todos
	Eugenia Bahit. Curso: Python para Principiantes
	Python Software Foundation. Overview - Python 2.7.10 documentation. https://docs.python.org/2.7/
	Python Software Foundation. Overview - Python 3.5.0 documentation. https://docs.python.org/3.5/
	creamostuweb (https://www.blogger.com/profile/05907170252728070066). Programacion en python. http://pycol.blogspot.com/
	Bartolomé Sintes Marco. Introducción a la programación con Python. http://www.mclibre.org/consultar/python/index.html
	Javier Montero. El Club del Autodidacta. http://elclubdelautodidacta.es/wp/
	Raúl González Duque. Documentanción en Python. http://mundogeek.net/archivos/2008/07/07/documentacion-en-python/
	stack exchange inc. Stack Overflow. http://stackoverflow.com/
	Python Software Foundation. PEP 0249 -- Python Database API Specification v2.0 | Python.org. https://www.python.org/dev/peps/pep-0249/
	Python Software Foundation. PEP 3333 -- Python Web Server Gateway Interface v1.0.1 | Python.org. https://www.python.org/dev/peps/pep-3333/#environ-variables