. Instalar los paquetes:
	git

. Uso:
	1. Iniciar el repositorio:
		Hay dos maneras por las cuales puede inicializarce un repositorio:
			1. Crear un nuevo repositorio:
				git init [<ruta/repositorio>]

				Nota: La ruta solo es necesaria si no esta dentro del repositorio a inicializar.

			2. Clonar un repositorio existente:
				git clone <protocolo> [<ruta/nuevoNombre>]

				Un repositorio puede ser clonado por medio de varios protocolos:
					. Local:
						/<ruta>/<repositorio>.git
						file:///<ruta>/<repositorio>.git

					. HTTPS: 
						https://<servidor.dom>/<usuario>/<repositorio>.git

					. SSH:
						git@<servidor.dom>:<usuario>/<repositorio>.git
						ssh://<usuario>@<servidor.com>[:<puerto>]/<repositorio>

				Nota: El nuevo nombre solo es necesario si se desea que el repositorio clonado sea renombrado, no puede existir el nombre especificado.

		Configuración básica:
			Asignar los datos del autor para las actividades de Git:
				git config user.name "<usuario>"
				git config user.email "<correo>"

	2. Trabajar en el repositorio:
		Metafóricamente Git podría representarse como un escritorio, una bandeja y un archivero. El escritorio es donde se agregan todos los archivos en los que se trabajarán (la carpeta del repositorio), la bandeja es donde estarán los posibles archivos a guardarse (los archivos preparados) y en el archivero se guardarán todas las versiones de los archivos que se deseen mantener en el tiempo (los cambios confirmados o commits), esto da la posibilidad de restaurar ciertos archivos o en casos extremos regresar el proyecto completo a un estado anterior.

		. Verificar el estado del repositorio:
			Permite saber que archivos no están siendo controlados por Git, si se han hecho cambios y no se han confimado o cualquier otra información relevante sobre el estado del repositorio. Se debe ejecutar el comando:
				git status

		. Agregar archivos:
			Todo nuevo archivo agregado es etiquetado como untracked, ya que Git por defecto excluye los ficheros para evitar versionar alguno que no sea necesario (como archivos creados dinamicamente por el mismo proyecto, archivos temporales, configuraciones del sistema operativo, cache, etc..), por ello se debe utilizar un comando para que los tome en cuenta en la próxima confirmación:
				Todos:
					git add .

				Especificos:
					git add <archivo>

					Nota: add soporta carpetas y patrones glob, anteponiendo "\" a los comodines.

		. Ignorar archivos:
			Git da la posibilidad de crear una lista de archivos ignorados para evitar que cualquier acción de Git los tome en cuenta (status, add, etc..), ésta lista debe guardarse en un archivo con nombre .gitignore en la raiz del repositorio y debe cumplir la siguientes normas:
				. Para escribir comentarios se debe usar el carater "#"
				. Para negar expresiones se debe usar el caracter "!"
				. Para referirse a carpetas se debe escribir el caracter "/" al final del nombre
				. Para hacer referencia a la raiz del repositorio se debe usar el caracter "/" al principio
				. Se pueden usar patrones glob:
					? -> Cualquier caracter
					* -> Cualquier cantidad de carateres
					[] -> Grupo de caracteres y rangos

					Ejemplos:
						# Comentario

						file?.* # Ignora todos los archivos con cualquier extensión que su nombre empiece en "file" y termine en cualquier caracter
						
						!file[0-1]* # Toma en cuenta cualquier archivo que tenga como nombre "file" y termine en un número

						[._]* # Ignora cualquer archivo que empiece con "." o "_"
						
						carpeta/ # Ignora la carpeta y su contenido

						/archivo.txt # Ignora el archivo con extensión "txt" que solo se encuentran en la raiz del repositorio

		. Modificar archivos:
			Al modificar archivos que ya habian sido agregados, estos dejan de estar listos para ser confirmados por lo que deben ser preparados nuevamente con el comando add. En caso de no agregarlos, se confirmarán los cambios que se habian preparado antes de ser modificados o simplemente seran ignorados si no se prepararon antes.

			Ejemplo:
				touch README
				git add README
				echo "Nuevo conetenido" > README

				Apesar de que el contenido del archivo README ha cambiado, Git tiene ordenado que en la proxima confirmación tome en cuenta sólo la creación del archivo.

			Git tiene una herramienta que permite conocer con exactitud los cambios que se han realizado, puede usarse para comprar entre el área de trabajo actual y los archivos preparados o para comparar entre los archivos preparados y los cambios que ya están confirmados:
				Modified - Staged (Actuales - Preparados):
					git diff [<archivo>]

				Staged - Commited (Preparados - Confirmados):
					git diff --staged [<archivo>]

				Nota: Si no hay archivos preparados y se usa git diff, comparará el área de trabajo actual con los cambios confirmados.

		. Eliminar archivos:
			Para eliminar archivos de Git es necesario usar el comando:
				git rm [-f] [-r] <archivo>

				Parametros:
					-f: Es recomendable usar el parametro force cuando el archivo a eliminar ha sido preparado anteriormente.
					-r: Recursivo, se debe usar si se intenta eliminar una carpeta.

				Nota: rm soporta carpetas y patrones glob, anteponiendo "\" a los comodines.

			Para eliminar seguimiento de Git (untrack):
				git rm --cached <archivo>

		. Renombrar/Mover archivos:
			Al renombrar o mover archivos con comandos del sistema, Git asume que el archivo original se eliminó y se agregó uno nuevo. Realmente ésto no afecta mucho a Git ya que hasta ahora con add y rm puede solucionarse rapidamente pero a pesar de ello, existe un comando propio que cumple dicha función y hace que Git sepa que se ha renombrado:
				git mv <archivo> <nuevoNombre>

		. Confirmar los cambios:
			git commit [-a] [-m "<Mensaje>"] [-- <patrónGLOB>]

			Parametros:
				-a: Prepara automaticamente todos los archivos bajo seguimiento de Git y confirma los cambios, evitando el uso de add y rm.
				-m <"Mensaje">: Permite indicar automaticamente el mensaje de la confirmación sin tener que usar un editor de texto.
				[-- <patrónGLOB>]: Permite realizar una confirmación con los archivos especificados.

		. Ver registro de confirmaciones:
			Cada confirmación es almacenada e identificada con un hash de SHA-1, es posible mostrar la lista de confirmaciones con el comando:
				git log [<parametros>] [-- <archivo>]

				Parametros:
					Filtro:
						-<n>: Indica la cantidad de confirmaciones a mostrar.
						--since=<fecha> o --after=<fecha>: Muestra las confirmaciones desde la fecha especificada.
							Especificas: "YYYY-MM-DD HH:MM:SS", ejemplo:
								git log --since="2015-01-01 00:00"

							Relativas: <n>.years.<n>.months.<n>.weeks.<n>.days.<n>.hours.<n>.minutes.<n>.seconds, ejemplo:
								git log --after=1.month.2.weeks
						--until=<fecha> o --before=<fecha>: Muestra las confirmaciones hasta la fecha especificada.
						--author=<autor>: Muestra solo las confirmaciones del autor especificado.
						--committer=<confirmador>: Muestra solo las confirmaciones del confirmador especificado.

						Nota: Para que se muestren solo las confirmaciones que cumplan con todos los filtros de debe utilizar el parametro --all-match.

					Formato:
						-p: Muestra las diferencias de las confirmaciones.
						--abbrev-commit: Abrevia el hash de las confirmaciones.
						--stat: Muestra las estadísticas de los archivos de cada confimación.
						--shortstat: Muestra solo las estadísticas de las confimaciones.
						--name-only: Muestra el nombre de los archivos modificados en las confirmaciones, pero no las modificaciones.
						--name-status: Muestra los archivos confirmados e indica si fueron agregados, modificados o eliminados.
						--relative-date: Formatea la fecha de manera relativa (el tiempo transcurrido desde la fecha de confirmación hasta la fecha actual).
						--graph: Muestra la linea de vida del repositorios y sus ramas.
						--pretty: Cambia el formato de salida de las confirmaciones.
							online: Muestra cada confirmación en una linea
							short: Muestra las confirmaciones sin la fecha.
							full: Muestra el autor y el confirmador.
							fuller: Muestra todo.
							format:"<formato>": Permite establecer el formato de salida de log.
								%H	Hash de la confirmación.
								%h	Hash de la confirmación abreviado.
								%T	Hash del árbol.
								%t	Hash del árbol abreviado.
								%P	Hashes de las confirmaciones padre.
								%p	Hashes de las confirmaciones padre abreviados.
								%an	Nombre del autor.
								%ae	Correo electrónico del autor.
								%ad	Fecha de autoría.
								%ar	Fecha relativa de autoría.
								%cn	Nombre del confirmador.
								%ce	Dirección de correo del confirmador.
								%cd	Fecha de confirmación.
								%cr	Fecha relativa de confirmación.
								%s	Asunto.
						--online: Combina --abbrev-commit y --pretty=oneline.

				Nota: Para obtener la lista de participantes del proyecto con sus confirmaciones se puede usar el comando:
					git shortlog

		.Etiquetas:
			Permiten identificar confirmaciones para trabajar con mayor precisión en ellas.

			. Mostrar etiquetas:
				git tag [-l '<patrón>']

				Parametros:
					-l '<patrón>': Permite filtrar la lista de etiquetas con patrones glob.

				Nota: Para obtener aún más información sobre las etiquetas se usa el comando:
					git show <etiqueta>

			. Crear etiquetas:
				Existen dos tipos de etiquetas:
					1. Ligeras:
						Permiten identificar alguna comprobación.
							git tag <etiqueta> [<hashConfirmación>]

					2. Anotadas:
						Son etiquetas mas complejas, contienen información de quién creó la etiqueta, la fecha en que fue creada y otra información util.
							git tag -a <etiqueta> [-m "<mensaje>"] [<hashConfirmación>]

			. Eliminar etiquetas:
				git tag -d <etiqueta>

		. Deshacer cambios:
			Archivos:
				git checkout [<confirmación>] -- <archivo> | .

				Nota: Si no se especifica una confirmación, se hará referencia a la ultima confirmación.

				Para hacer referencia a una confirmación existen varios metodos:
					. Hash corto:
						No es necesario escribir completamente el hash identificador, con el comando git log --oneline es posible conocer los hash resumidos.

					. Etiquetas y ramas:
						Al escribir el nombre de una etiqueta o rama se hará referencia a la confirmacion que esta apunta.

					. Registro de referencia:
						Git almacena la actividad del usuario en el reflog, es posible obtener este registro con el comando git reflog y para hacer referencia a un objeto dentro de él se debe usar su identificador HEAD@{<número>}

			Preparación:
				Para quitar un archivo de la lista a confirmar es necesario usar el comando:
					git reset HEAD <archivo>

			Confimación:
				git commit --amend [--reset-author]

				Nota: Si se ejecuta el comando y no se ha hecho algún cambio desde la última confirmación solo modificará su mensaje.

				En caso de querer regresar a confirmaciones anteriores y borrar las que sigan de ellas se debe usar el comando:
					git reset --hard [<confirmación>]

	3. Ramas:
		Permiten desviar proyectos de su objetivo principal para realizar algún cambio específico sin correr el riesgo de dañar cualquier archivo importante, para despues fusionar dichos cambios (si se obtuvieron los resultados esperados) con el proyecto principal.

		. Mostrar ramas:
			git branch [-v] [--merged | --no-merged]

			Nota: El "*" identifica la rama activa.

			Parametros:
				-v: Muestra la confirmación a la que apunta la rama.
				--merged: Muestra las ramas que ya fueron mezcladas con la rama activa.
				--no-merged: Muestra las ramas que no han sido mezcladas con la rama activa.

		. Crear ramas:
			git branch <rama> [<confirmaciónBase>]

			Nota: Para activar la rama se debe usar el comando git checkout <rama>. Si se desea crear y activar instantaneamente una rama puede usarse el comando git checkout -b <rama> [<confirmaciónBase>].

			Nota 2: Cuando se especifica una confirmación se creará una rama con su contenido, esto es útil para crear ramas sin tener que desactivar la rama actual o crear copias locales de ramas remotas ya que estas solo pueden editarse con los datos que se obtengan de algún servidor.

		. Mezclar ramas:
			Al mezclar ramas, se copia el contenido de la rama especificada en la rama activa, por lo que solo se verá afectada esta ultima. Se debe usar el comando:
				git merge <rama> [<ramaDestino>]

			Si se encuentran conflictos en archivos, se modificara su contenido indicando donde estan las diferencias. Ejemplo:
				<<<<<<< HEAD
				Contenido actual
				=======
				Contenido nuevo
				>>>>>>> rama

				Nota: Al realizar la mezcla se creará un archivo .orig que contendrá la información del archivo con las marcas de conflicto, si se realizaron correctamente los cambios puede ser eliminado.

			Es posible hacer una copia de una confirmación específica de una rama, aunque a diferencia de git merge el registro de cambios no se visualizará por lo que la confirmación copiada se posicionará como una nueva.
				git cherry-pick [<confirmación>]

		. Diferencias entre ramas:	
			git diff <rama>

			Nota: Si la rama especificada fue usada como base para la rama actual y ha avanzado desde entonces, la salida no será la esperada por lo que se recomienda usar el comando:
				git diff <rama>...<ramaActual>

		. Eliminar ramas:
			git branch -d <rama>

			Nota: Si la rama a eliminar no ha sido mezclada con la rama activa, es necesario cambiar el parametro -d por -D.

	4. Repositorios remotos:
		. Mostrar repositorios remotos actuales:
			git remote [-v]

			Parametros:
				-v: Muestra la URL de cada repositorio.

			Nota: Para obtener aún más información sobre los repositorios remotos se usa el comando:
				git remote show <repositorio>

		. Agregar respositorio remoto:
			git remote add [<nombre>] <protocolo>

		. Renombrar repositorio remoto:
			git remote rename <repositorio> <nuevoNombre>

		. Cambiar ruta del repositorio remoto:
			git remote set-url [--push] <repositorio> <nuevaRuta>

			Parametros:
				--push: Cambia solo la ruta a la que se enviarán los cambios.

		. Eliminar repositorio remoto:
			git remote rm <repositorio>

		. Obtener información de un repositorio remoto:
			Git permite obtener información de repositorios remotos mediante dos métodos:
				1. Sin afectar el área de trabajo:
					git fetch [<repositorio>]

					Actualiza las confirmaciones hasta el punto mas reciente del repositorio remoto, el área de trabajo se mantiene intacta.

				2. Actualizando automaticamente el área de trabajo:
					git pull [<repositorio>]

					Actualiza las confirmaciones hasta el punto mas reciente del repositorio remoto y establece el área de trabajo al estado de la ultima confirmación, si existen cambios sin confirmar en el área de trabajo actual el comando no se ejecutara.

		. Cargar información a un repositorios remoto:
			git push [-f] [<repositorio>] [<rama>][:<ramaDestino>]

			Parametros:
				-f: Sobrescribe la información del repositorio remoto con la información local.

			Solo podrá enviarse información a un repositorio remoto del que se tengan las confirmaciones actualizadas, de lo contrario se deberán actualizar los datos locales para que se puedan cargar los cambios.

			Nota: Si no se especifica una rama local pero si una destino, se eliminará la rama especificada en el servidor, ejemplo:
				git push origin :rama

			Nota 2: Para cargar las etiquetas debe especificarse el nombre de la etiqueta o el parametro --tags para enviarlas todas, ejemplo:
				git push [<repositorio>] <etiqueta> | --tags

	5. Exportar el proyecto:
		Es posible exportar el proyecto a un archivo para facilitar su transmisión o simplemente liberar una versión, se debe usar el comando:
			git archive <rama> [-v] [--prefix='<carpetaContenedora>/'] [--format=<formato>] -o <archivo>.<formato>

			Parametros:
				-v: Mostrará la lista de archivos exportados.
				--prefix='<carpetaContenedora>/': Agregará lo indicado antes del nombre de cada archivo, el / es usado para crear la carpeta.
				--format=<formato>: Determina el formato del archivo comprimido exportado:
					. tar
					. tgz
					. tar.gz
					. zip
				-o <archivo>.<formato>: Crea el archivo.

. Buenas practicas:
	. Una confirmación debe abarcar un cambio o la solución a un problema específico.

	. Verificar que los archivos modificados no contengan espacios innecesarios antes de ser confirmados:
		git diff --check

	. Formato de mensaje de confirmación:
		Descripción general de cambios. <= 50 caracteres.

		Descripción detallada de los cambios realizados, debe serpararse por una
		linea en blanco <= 72 caracteres por linea.

	. Ramas:
		Se recomiendan 4 tipos de ramas:
			1. master: Rama principal de proyecto, debe contener solo contenido estable.
			2. hotfix o security: Son ramas especializadas en atacar algún error critico de la rama principal.
			3. development o testing: Es la rama en la que se probarán todas las nuevas funcionalidades y cuando alcance un buen nivel de estabilidad se mezclará con la rama master.
			4. features: Son todas las ramas que contengan nuevas funcionalidades para ser probadas en la rama testing.

. Utilidades:
	. Guardar cambios del área de trabajo sin confirmaciones:
		En caso de tener que usar algún comando que necesite de un área de trabajo limpia y se ha estado trabajando en ella, se puede guardar el estado actual del área de trabajo y restaurarse posteriormente en cualquier momento o rama. Se usa el comando:
			git stash

		Si se ha usado repetidas veces este comando, Git almacena cada área de trabajo en una pila, es posible obtener la lista de áreas de trabajo guardadas agregando el parametro list:
			git stash list

		Para restaurar:
			En la rama actual:
				git stash apply | pop [--index] [<áreaGuardada>]

				Parametros:
					--index: Intenta preparar los archivos que habian sido preparados cuando se guardó el área de trabajo.

				Nota: La unica diferencia entre apply y pop es que pop elimina el área de trabajo restaurada de la pila.

			En una rama nueva:
				git stash branch <rama> [<áreaGuardada>]
			
			Nota: Si no se especifica un área de trabajo de la pila, se restaurará el ultimo elemento guardado.

		Para eliminar:
			Todas:
				git stash clear

			Específica:
				git stash drop [<áreaGuardada>]

				Nota: Si no se especifica un área de trabajo de la pila, se eliminará el ultimo elemento guardado.

	. Modo interactivo:
		Se puede lanzar un modo interactivo de Git con el comando:
			git add -i

	. Ver el registro de cambios por linea de un archivo:
		Es posible conocer por quien y cuando fue agregada o modificada cualquier linea de un archivo, se debe usar el comando:
			git blame [-b] [-l] [-n] [-s] [-e] [-w] [-L <inicio>,<fin>] [--abbrev[=<n>]]

			Parametros:
				-b: Omite la confirmación de origen (en la que se agrego por primera vez el archivo), marcada con el caracter ^.
				-l: Muestra el hash de la confirmación completo.
				-n: Muestra el numero real de la linea.
				-s: Elimina los datos del editor y la fecha.
				-e: Cambia el nombre del editor por su correo electrónico.
				-w: Ignora espacios en blanco.
				-L <inicio>,<fin>: Muestra las lineas entre los limites especificados.
				--abrev[=<n>]: Resume el hash a la cantidad de caracteres especificada, si no, se resume a 7 caracteres (o más si se necesitan para que sea unico).

	. Busqueda binaria de errores:
		Git permite realizar busquedas binarias entre confirmaciones para encontrar errores, se debe ejecutar el comando:
			git bisect start [<confirmaciónMala>] [<confirmaciónBuena>]

			El área de trabajo se llevará al estado de la confirmación intermedia entre las dos especificadas para verificar si existe el error.

			Si existe:
				Se debe usar el comando git bisect bad para indicar que la confirmación seleccionada tambien presenta el error y Git realizará el mismo procedimiento de busqueda a partir de ella.

			Si no existe:
				Se debe usar el comando git bisect good para indicarle a Git que la confirmación no contiene el error y debe realizar la busqueda nuevamente hasta ella.

			Una vez que se hayan obtenido los resultado esperados o ya no se desee seguir buscado, se debe restaurar el area de trabajo con el comando:
				git bisect reset

	. Repositorios dentro de un repositorio (submódulos):
		Es posible que sea necesario clonar algun repositorio que contenga algunas bibliotecas que serán usadas para el proyecto, por tanto dicho repositorio deberia tener un control de Git independiente al repositorio principal.

		. Agregar un submódulo:
			git submodule add <protocolo> [<ruta/nuevoNombre>]

		. Actualizar enlaces de los submodulos:
			En caso de que el repositorio de un submódulo cambie de nombre, de servidor donde se aloja o simplemente el protocolo de clonación se debe cambiar manualmente la dirección del repositorio remoto en el submódulo y luego sincronizarla con la del archivo .gitmodules del proyecto principal con el comando:
				git submodule sync [-- <submódulo>]

				Parametros:
					-- <submódulo>: Para actualizar un submódulo en específico.

		. Clonar un repositorio con submódulos:
			1. Clonar el repositorio principal.
			2. Inicializar el archivo .gitmodules con el comando:
				git submodule init
			3. Clonar los submódulos inicializados:
				git submodule update

				Nota: Usar pull o cambiar la rama dentro de los submódulos cambiaría su área de trabajo, por lo que este comando tambien sirve para llevar el estado del área de trabajo de los submódulos al de la confirmación que es usada por el repositorio principal.

	. Atributos de Git:
		Normalmente se guardan en el archivo ".gitattributes" en la raiz del proyecto y comparte su sintaxis con ".gitingnore".

		. Ignorar archivos al exportar el proyecto:
			<patrónGLOB> export-ignore

		. Evitar mezcla de archivos:
			<patrónGLOB> merge=ours

. Configuración avanzada:
	Existen tres niveles de configuración en git:
		1. Sistema (git config --system): Aplica a todos los usuarios del sistema.
		2. Usuario (git config --global): Aplica a todos los repositorios de el usuario con que se ejecute el comando.
		3. Repositorio (git config): Aplica solo al repositorio donde se ejecuto el comando.

		Nota: Git lee las configuraciones de la siguente manera, Repositorio > Usuario > Sistema.

	Para ver la configuración actual de Git se debe ejecutar alguno de los siguientes comandos:
		. Toda:
			git config [<nivel>] -l
		. Específica:
			git config [<nivel>] <configuración>

	Algunas configuraciones útiles:
		. Alias:
			Git tiene la funcionalidad de crear comandos personalizados que hagan referencia a otros:
				git config [<nivel>] alias.<alias> <comando> | '<comando con espacios>' | '!<comandoExterno>'

				Ejemplos:
					git config alias.cm commit -> git cm == git commit
					git config alias.cm 'commit -m' -> git commit -m "Mensaje" == git cm "Mensaje"
					git config alias.ignore '!nano .gitignore' -> nano .gitignore == git ignore

		. Autor:
			git config [<nivel>] user.name "<usuario>"
			git config [<nivel>] user.email "<correo>"

		. Colores:
			git config [<nivel>] color.ui true

			Nota: Tambien se puede especificar el valor "always" para que Git mantega los colores cuando la salida de algun comando se guarde en un archivo.

			Tambien es posible especificar que se deberá colorear, como el registro de confirmaciones o el estado del repositorio:
				git config [<nivel>] color.<opcion>

			Lista de colores:
				. Amarillo: yellow.
				. Azul: blue.
				. Azul claro: cyan.
				. Blanco: white.
				. Negro: black.
				. Predeterminado del terminal: normal.
				. Rojo oscuro: magenta.
				. Verde: green.

			Estilos:
				. Negrita: bold.
				. Tenue: dim.
				. Subrayado: ul.
				. Parpadeante: blink.
				. Inverso: reverse.

		. Editor de texto:
			git config [<nivel>] core.editor <editor>

		. Herramienta de fusión:
			git config [<nivel>] merge.tool <herramienta>

			Ejemplo con Sublime Text 3:
				git config merge.tool subl
				git config mergetool.subl.cmd "subl -w \$MERGED"

				Nota: El parametro -w <archivo> de Sublime Text abre el archivo especificado, la varible \$MERGED contiene el nombre del archivo a ser mezclado.

		. Ignorar archivos:
			git config [<nivel>] core.excludesfile <ruta/archivo>

			Nota: Esta configuración funciona igual que el archivo .gitignore, por lo que el archivo indicado deberá estar escrito con dicha sintaxis.

		. Plantilla para mensaje de confirmación:
			git config [<nivel>] commit.template <ruta/archivo>

	Si se desea eliminar alguna configuración se debe usar el parametro --unset:
		git config [<nivel>] --unset <configuración>

Referencias:
	LibrosWeb.es. Pro Git, el libro oficial de Git. http://librosweb.es/libro/pro_git/